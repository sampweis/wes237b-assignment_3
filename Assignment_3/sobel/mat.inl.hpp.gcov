        -:    0:Source:/usr/include/opencv4/opencv2/core/mat.inl.hpp
        -:    0:Graph:objs/student_sobel.gcno
        -:    0:Data:objs/student_sobel.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*M///////////////////////////////////////////////////////////////////////////////////////
        -:    2://
        -:    3://  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
        -:    4://
        -:    5://  By downloading, copying, installing or using the software you agree to this license.
        -:    6://  If you do not agree to this license, do not download, install,
        -:    7://  copy or use the software.
        -:    8://
        -:    9://
        -:   10://                          License Agreement
        -:   11://                For Open Source Computer Vision Library
        -:   12://
        -:   13:// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
        -:   14:// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
        -:   15:// Copyright (C) 2013, OpenCV Foundation, all rights reserved.
        -:   16:// Copyright (C) 2015, Itseez Inc., all rights reserved.
        -:   17:// Third party copyrights are property of their respective owners.
        -:   18://
        -:   19:// Redistribution and use in source and binary forms, with or without modification,
        -:   20:// are permitted provided that the following conditions are met:
        -:   21://
        -:   22://   * Redistribution's of source code must retain the above copyright notice,
        -:   23://     this list of conditions and the following disclaimer.
        -:   24://
        -:   25://   * Redistribution's in binary form must reproduce the above copyright notice,
        -:   26://     this list of conditions and the following disclaimer in the documentation
        -:   27://     and/or other materials provided with the distribution.
        -:   28://
        -:   29://   * The name of the copyright holders may not be used to endorse or promote products
        -:   30://     derived from this software without specific prior written permission.
        -:   31://
        -:   32:// This software is provided by the copyright holders and contributors "as is" and
        -:   33:// any express or implied warranties, including, but not limited to, the implied
        -:   34:// warranties of merchantability and fitness for a particular purpose are disclaimed.
        -:   35:// In no event shall the Intel Corporation or contributors be liable for any direct,
        -:   36:// indirect, incidental, special, exemplary, or consequential damages
        -:   37:// (including, but not limited to, procurement of substitute goods or services;
        -:   38:// loss of use, data, or profits; or business interruption) however caused
        -:   39:// and on any theory of liability, whether in contract, strict liability,
        -:   40:// or tort (including negligence or otherwise) arising in any way out of
        -:   41:// the use of this software, even if advised of the possibility of such damage.
        -:   42://
        -:   43://M*/
        -:   44:
        -:   45:#ifndef OPENCV_CORE_MATRIX_OPERATIONS_HPP
        -:   46:#define OPENCV_CORE_MATRIX_OPERATIONS_HPP
        -:   47:
        -:   48:#ifndef __cplusplus
        -:   49:#  error mat.inl.hpp header must be compiled as C++
        -:   50:#endif
        -:   51:
        -:   52:#ifdef _MSC_VER
        -:   53:#pragma warning( push )
        -:   54:#pragma warning( disable: 4127 )
        -:   55:#endif
        -:   56:
        -:   57:namespace cv
        -:   58:{
        -:   59:CV__DEBUG_NS_BEGIN
        -:   60:
        -:   61:
        -:   62://! @cond IGNORED
        -:   63:
        -:   64:////////////////////////// Custom (raw) type wrapper //////////////////////////
        -:   65:
        -:   66:template<typename _Tp> static inline
        -:   67:int rawType()
        -:   68:{
        -:   69:    CV_StaticAssert(sizeof(_Tp) <= CV_CN_MAX, "sizeof(_Tp) is too large");
        -:   70:    const int elemSize = sizeof(_Tp);
        -:   71:    return (int)CV_MAKETYPE(CV_8U, elemSize);
        -:   72:}
        -:   73:
        -:   74://////////////////////// Input/Output Arrays ////////////////////////
        -:   75:
        -:   76:inline void _InputArray::init(int _flags, const void* _obj)
        -:   77:{ flags = _flags; obj = (void*)_obj; }
        -:   78:
        -:   79:inline void _InputArray::init(int _flags, const void* _obj, Size _sz)
        -:   80:{ flags = _flags; obj = (void*)_obj; sz = _sz; }
        -:   81:
        -:   82:inline void* _InputArray::getObj() const { return obj; }
        -:   83:inline int _InputArray::getFlags() const { return flags; }
        -:   84:inline Size _InputArray::getSz() const { return sz; }
        -:   85:
        -:   86:inline _InputArray::_InputArray() { init(0 + NONE, 0); }
        -:   87:inline _InputArray::_InputArray(int _flags, void* _obj) { init(_flags, _obj); }
        -:   88:inline _InputArray::_InputArray(const Mat& m) { init(MAT+ACCESS_READ, &m); }
        -:   89:inline _InputArray::_InputArray(const std::vector<Mat>& vec) { init(STD_VECTOR_MAT+ACCESS_READ, &vec); }
        -:   90:inline _InputArray::_InputArray(const UMat& m) { init(UMAT+ACCESS_READ, &m); }
        -:   91:inline _InputArray::_InputArray(const std::vector<UMat>& vec) { init(STD_VECTOR_UMAT+ACCESS_READ, &vec); }
        -:   92:
        -:   93:template<typename _Tp> inline
        -:   94:_InputArray::_InputArray(const std::vector<_Tp>& vec)
        -:   95:{ init(FIXED_TYPE + STD_VECTOR + traits::Type<_Tp>::value + ACCESS_READ, &vec); }
        -:   96:
        -:   97:template<typename _Tp, std::size_t _Nm> inline
        -:   98:_InputArray::_InputArray(const std::array<_Tp, _Nm>& arr)
        -:   99:{ init(FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_READ, arr.data(), Size(1, _Nm)); }
        -:  100:
        -:  101:template<std::size_t _Nm> inline
        -:  102:_InputArray::_InputArray(const std::array<Mat, _Nm>& arr)
        -:  103:{ init(STD_ARRAY_MAT + ACCESS_READ, arr.data(), Size(1, _Nm)); }
        -:  104:
        -:  105:inline
        -:  106:_InputArray::_InputArray(const std::vector<bool>& vec)
        -:  107:{ init(FIXED_TYPE + STD_BOOL_VECTOR + traits::Type<bool>::value + ACCESS_READ, &vec); }
        -:  108:
        -:  109:template<typename _Tp> inline
        -:  110:_InputArray::_InputArray(const std::vector<std::vector<_Tp> >& vec)
        -:  111:{ init(FIXED_TYPE + STD_VECTOR_VECTOR + traits::Type<_Tp>::value + ACCESS_READ, &vec); }
        -:  112:
        -:  113:template<typename _Tp> inline
        -:  114:_InputArray::_InputArray(const std::vector<Mat_<_Tp> >& vec)
        -:  115:{ init(FIXED_TYPE + STD_VECTOR_MAT + traits::Type<_Tp>::value + ACCESS_READ, &vec); }
        -:  116:
        -:  117:template<typename _Tp, int m, int n> inline
        -:  118:_InputArray::_InputArray(const Matx<_Tp, m, n>& mtx)
        -:  119:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_READ, &mtx, Size(n, m)); }
        -:  120:
        -:  121:template<typename _Tp> inline
        -:  122:_InputArray::_InputArray(const _Tp* vec, int n)
        -:  123:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_READ, vec, Size(n, 1)); }
        -:  124:
        -:  125:template<typename _Tp> inline
        -:  126:_InputArray::_InputArray(const Mat_<_Tp>& m)
        -:  127:{ init(FIXED_TYPE + MAT + traits::Type<_Tp>::value + ACCESS_READ, &m); }
        -:  128:
        -:  129:inline _InputArray::_InputArray(const double& val)
        -:  130:{ init(FIXED_TYPE + FIXED_SIZE + MATX + CV_64F + ACCESS_READ, &val, Size(1,1)); }
        -:  131:
        -:  132:inline _InputArray::_InputArray(const MatExpr& expr)
        -:  133:{ init(FIXED_TYPE + FIXED_SIZE + EXPR + ACCESS_READ, &expr); }
        -:  134:
        -:  135:inline _InputArray::_InputArray(const cuda::GpuMat& d_mat)
        -:  136:{ init(CUDA_GPU_MAT + ACCESS_READ, &d_mat); }
        -:  137:
        -:  138:inline _InputArray::_InputArray(const std::vector<cuda::GpuMat>& d_mat)
        -:  139:{	init(STD_VECTOR_CUDA_GPU_MAT + ACCESS_READ, &d_mat);}
        -:  140:
        -:  141:inline _InputArray::_InputArray(const ogl::Buffer& buf)
        -:  142:{ init(OPENGL_BUFFER + ACCESS_READ, &buf); }
        -:  143:
        -:  144:inline _InputArray::_InputArray(const cuda::HostMem& cuda_mem)
        -:  145:{ init(CUDA_HOST_MEM + ACCESS_READ, &cuda_mem); }
        -:  146:
        -:  147:template<typename _Tp> inline
        -:  148:_InputArray _InputArray::rawIn(const std::vector<_Tp>& vec)
        -:  149:{
        -:  150:    _InputArray v;
        -:  151:    v.flags = _InputArray::FIXED_TYPE + _InputArray::STD_VECTOR + rawType<_Tp>() + ACCESS_READ;
        -:  152:    v.obj = (void*)&vec;
        -:  153:    return v;
        -:  154:}
        -:  155:
        -:  156:template<typename _Tp, std::size_t _Nm> inline
        -:  157:_InputArray _InputArray::rawIn(const std::array<_Tp, _Nm>& arr)
        -:  158:{
        -:  159:    _InputArray v;
        -:  160:    v.flags = FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_READ;
        -:  161:    v.obj = (void*)arr.data();
        -:  162:    v.sz = Size(1, _Nm);
        -:  163:    return v;
        -:  164:}
        -:  165:
        -:  166:inline _InputArray::~_InputArray() {}
        -:  167:
        -:  168:inline Mat _InputArray::getMat(int i) const
        -:  169:{
        -:  170:    if( kind() == MAT && i < 0 )
        -:  171:        return *(const Mat*)obj;
        -:  172:    return getMat_(i);
        -:  173:}
        -:  174:
        -:  175:inline bool _InputArray::isMat() const { return kind() == _InputArray::MAT; }
        -:  176:inline bool _InputArray::isUMat() const  { return kind() == _InputArray::UMAT; }
        -:  177:inline bool _InputArray::isMatVector() const { return kind() == _InputArray::STD_VECTOR_MAT; }
        -:  178:inline bool _InputArray::isUMatVector() const  { return kind() == _InputArray::STD_VECTOR_UMAT; }
        -:  179:inline bool _InputArray::isMatx() const { return kind() == _InputArray::MATX; }
        -:  180:inline bool _InputArray::isVector() const { return kind() == _InputArray::STD_VECTOR ||
        -:  181:                                                   kind() == _InputArray::STD_BOOL_VECTOR ||
        -:  182:                                                   kind() == _InputArray::STD_ARRAY; }
        -:  183:inline bool _InputArray::isGpuMat() const { return kind() == _InputArray::CUDA_GPU_MAT; }
        -:  184:inline bool _InputArray::isGpuMatVector() const { return kind() == _InputArray::STD_VECTOR_CUDA_GPU_MAT; }
        -:  185:
        -:  186:////////////////////////////////////////////////////////////////////////////////////////
        -:  187:
        -:  188:inline _OutputArray::_OutputArray() { init(NONE + ACCESS_WRITE, 0); }
        -:  189:inline _OutputArray::_OutputArray(int _flags, void* _obj) { init(_flags + ACCESS_WRITE, _obj); }
        -:  190:inline _OutputArray::_OutputArray(Mat& m) { init(MAT+ACCESS_WRITE, &m); }
        -:  191:inline _OutputArray::_OutputArray(std::vector<Mat>& vec) { init(STD_VECTOR_MAT + ACCESS_WRITE, &vec); }
        -:  192:inline _OutputArray::_OutputArray(UMat& m) { init(UMAT + ACCESS_WRITE, &m); }
        -:  193:inline _OutputArray::_OutputArray(std::vector<UMat>& vec) { init(STD_VECTOR_UMAT + ACCESS_WRITE, &vec); }
        -:  194:
        -:  195:template<typename _Tp> inline
        -:  196:_OutputArray::_OutputArray(std::vector<_Tp>& vec)
        -:  197:{ init(FIXED_TYPE + STD_VECTOR + traits::Type<_Tp>::value + ACCESS_WRITE, &vec); }
        -:  198:
        -:  199:template<typename _Tp, std::size_t _Nm> inline
        -:  200:_OutputArray::_OutputArray(std::array<_Tp, _Nm>& arr)
        -:  201:{ init(FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_WRITE, arr.data(), Size(1, _Nm)); }
        -:  202:
        -:  203:template<std::size_t _Nm> inline
        -:  204:_OutputArray::_OutputArray(std::array<Mat, _Nm>& arr)
        -:  205:{ init(STD_ARRAY_MAT + ACCESS_WRITE, arr.data(), Size(1, _Nm)); }
        -:  206:
        -:  207:template<typename _Tp> inline
        -:  208:_OutputArray::_OutputArray(std::vector<std::vector<_Tp> >& vec)
        -:  209:{ init(FIXED_TYPE + STD_VECTOR_VECTOR + traits::Type<_Tp>::value + ACCESS_WRITE, &vec); }
        -:  210:
        -:  211:template<typename _Tp> inline
        -:  212:_OutputArray::_OutputArray(std::vector<Mat_<_Tp> >& vec)
        -:  213:{ init(FIXED_TYPE + STD_VECTOR_MAT + traits::Type<_Tp>::value + ACCESS_WRITE, &vec); }
        -:  214:
        -:  215:template<typename _Tp> inline
        -:  216:_OutputArray::_OutputArray(Mat_<_Tp>& m)
        -:  217:{ init(FIXED_TYPE + MAT + traits::Type<_Tp>::value + ACCESS_WRITE, &m); }
        -:  218:
        -:  219:template<typename _Tp, int m, int n> inline
        -:  220:_OutputArray::_OutputArray(Matx<_Tp, m, n>& mtx)
        -:  221:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_WRITE, &mtx, Size(n, m)); }
        -:  222:
        -:  223:template<typename _Tp> inline
        -:  224:_OutputArray::_OutputArray(_Tp* vec, int n)
        -:  225:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_WRITE, vec, Size(n, 1)); }
        -:  226:
        -:  227:template<typename _Tp> inline
        -:  228:_OutputArray::_OutputArray(const std::vector<_Tp>& vec)
        -:  229:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR + traits::Type<_Tp>::value + ACCESS_WRITE, &vec); }
        -:  230:
        -:  231:template<typename _Tp, std::size_t _Nm> inline
        -:  232:_OutputArray::_OutputArray(const std::array<_Tp, _Nm>& arr)
        -:  233:{ init(FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_WRITE, arr.data(), Size(1, _Nm)); }
        -:  234:
        -:  235:template<std::size_t _Nm> inline
        -:  236:_OutputArray::_OutputArray(const std::array<Mat, _Nm>& arr)
        -:  237:{ init(FIXED_SIZE + STD_ARRAY_MAT + ACCESS_WRITE, arr.data(), Size(1, _Nm)); }
        -:  238:
        -:  239:template<typename _Tp> inline
        -:  240:_OutputArray::_OutputArray(const std::vector<std::vector<_Tp> >& vec)
        -:  241:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_VECTOR + traits::Type<_Tp>::value + ACCESS_WRITE, &vec); }
        -:  242:
        -:  243:template<typename _Tp> inline
        -:  244:_OutputArray::_OutputArray(const std::vector<Mat_<_Tp> >& vec)
        -:  245:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_MAT + traits::Type<_Tp>::value + ACCESS_WRITE, &vec); }
        -:  246:
        -:  247:template<typename _Tp> inline
        -:  248:_OutputArray::_OutputArray(const Mat_<_Tp>& m)
        -:  249:{ init(FIXED_TYPE + FIXED_SIZE + MAT + traits::Type<_Tp>::value + ACCESS_WRITE, &m); }
        -:  250:
        -:  251:template<typename _Tp, int m, int n> inline
        -:  252:_OutputArray::_OutputArray(const Matx<_Tp, m, n>& mtx)
        -:  253:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_WRITE, &mtx, Size(n, m)); }
        -:  254:
        -:  255:template<typename _Tp> inline
        -:  256:_OutputArray::_OutputArray(const _Tp* vec, int n)
        -:  257:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_WRITE, vec, Size(n, 1)); }
        -:  258:
        -:  259:inline _OutputArray::_OutputArray(cuda::GpuMat& d_mat)
        -:  260:{ init(CUDA_GPU_MAT + ACCESS_WRITE, &d_mat); }
        -:  261:
        -:  262:inline _OutputArray::_OutputArray(std::vector<cuda::GpuMat>& d_mat)
        -:  263:{	init(STD_VECTOR_CUDA_GPU_MAT + ACCESS_WRITE, &d_mat);}
        -:  264:
        -:  265:inline _OutputArray::_OutputArray(ogl::Buffer& buf)
        -:  266:{ init(OPENGL_BUFFER + ACCESS_WRITE, &buf); }
        -:  267:
        -:  268:inline _OutputArray::_OutputArray(cuda::HostMem& cuda_mem)
        -:  269:{ init(CUDA_HOST_MEM + ACCESS_WRITE, &cuda_mem); }
        -:  270:
        -:  271:inline _OutputArray::_OutputArray(const Mat& m)
        -:  272:{ init(FIXED_TYPE + FIXED_SIZE + MAT + ACCESS_WRITE, &m); }
        -:  273:
        -:  274:inline _OutputArray::_OutputArray(const std::vector<Mat>& vec)
        -:  275:{ init(FIXED_SIZE + STD_VECTOR_MAT + ACCESS_WRITE, &vec); }
        -:  276:
        -:  277:inline _OutputArray::_OutputArray(const UMat& m)
        -:  278:{ init(FIXED_TYPE + FIXED_SIZE + UMAT + ACCESS_WRITE, &m); }
        -:  279:
        -:  280:inline _OutputArray::_OutputArray(const std::vector<UMat>& vec)
        -:  281:{ init(FIXED_SIZE + STD_VECTOR_UMAT + ACCESS_WRITE, &vec); }
        -:  282:
        -:  283:inline _OutputArray::_OutputArray(const cuda::GpuMat& d_mat)
        -:  284:{ init(FIXED_TYPE + FIXED_SIZE + CUDA_GPU_MAT + ACCESS_WRITE, &d_mat); }
        -:  285:
        -:  286:
        -:  287:inline _OutputArray::_OutputArray(const ogl::Buffer& buf)
        -:  288:{ init(FIXED_TYPE + FIXED_SIZE + OPENGL_BUFFER + ACCESS_WRITE, &buf); }
        -:  289:
        -:  290:inline _OutputArray::_OutputArray(const cuda::HostMem& cuda_mem)
        -:  291:{ init(FIXED_TYPE + FIXED_SIZE + CUDA_HOST_MEM + ACCESS_WRITE, &cuda_mem); }
        -:  292:
        -:  293:template<typename _Tp> inline
        -:  294:_OutputArray _OutputArray::rawOut(std::vector<_Tp>& vec)
        -:  295:{
        -:  296:    _OutputArray v;
        -:  297:    v.flags = _InputArray::FIXED_TYPE + _InputArray::STD_VECTOR + rawType<_Tp>() + ACCESS_WRITE;
        -:  298:    v.obj = (void*)&vec;
        -:  299:    return v;
        -:  300:}
        -:  301:
        -:  302:template<typename _Tp, std::size_t _Nm> inline
        -:  303:_OutputArray _OutputArray::rawOut(std::array<_Tp, _Nm>& arr)
        -:  304:{
        -:  305:    _OutputArray v;
        -:  306:    v.flags = FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_WRITE;
        -:  307:    v.obj = (void*)arr.data();
        -:  308:    v.sz = Size(1, _Nm);
        -:  309:    return v;
        -:  310:}
        -:  311:
        -:  312:///////////////////////////////////////////////////////////////////////////////////////////
        -:  313:
        -:  314:inline _InputOutputArray::_InputOutputArray() { init(0+ACCESS_RW, 0); }
        -:  315:inline _InputOutputArray::_InputOutputArray(int _flags, void* _obj) { init(_flags+ACCESS_RW, _obj); }
        -:  316:inline _InputOutputArray::_InputOutputArray(Mat& m) { init(MAT+ACCESS_RW, &m); }
        -:  317:inline _InputOutputArray::_InputOutputArray(std::vector<Mat>& vec) { init(STD_VECTOR_MAT+ACCESS_RW, &vec); }
        -:  318:inline _InputOutputArray::_InputOutputArray(UMat& m) { init(UMAT+ACCESS_RW, &m); }
        -:  319:inline _InputOutputArray::_InputOutputArray(std::vector<UMat>& vec) { init(STD_VECTOR_UMAT+ACCESS_RW, &vec); }
        -:  320:
        -:  321:template<typename _Tp> inline
        -:  322:_InputOutputArray::_InputOutputArray(std::vector<_Tp>& vec)
        -:  323:{ init(FIXED_TYPE + STD_VECTOR + traits::Type<_Tp>::value + ACCESS_RW, &vec); }
        -:  324:
        -:  325:template<typename _Tp, std::size_t _Nm> inline
        -:  326:_InputOutputArray::_InputOutputArray(std::array<_Tp, _Nm>& arr)
        -:  327:{ init(FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_RW, arr.data(), Size(1, _Nm)); }
        -:  328:
        -:  329:template<std::size_t _Nm> inline
        -:  330:_InputOutputArray::_InputOutputArray(std::array<Mat, _Nm>& arr)
        -:  331:{ init(STD_ARRAY_MAT + ACCESS_RW, arr.data(), Size(1, _Nm)); }
        -:  332:
        -:  333:template<typename _Tp> inline
        -:  334:_InputOutputArray::_InputOutputArray(std::vector<std::vector<_Tp> >& vec)
        -:  335:{ init(FIXED_TYPE + STD_VECTOR_VECTOR + traits::Type<_Tp>::value + ACCESS_RW, &vec); }
        -:  336:
        -:  337:template<typename _Tp> inline
        -:  338:_InputOutputArray::_InputOutputArray(std::vector<Mat_<_Tp> >& vec)
        -:  339:{ init(FIXED_TYPE + STD_VECTOR_MAT + traits::Type<_Tp>::value + ACCESS_RW, &vec); }
        -:  340:
        -:  341:template<typename _Tp> inline
        -:  342:_InputOutputArray::_InputOutputArray(Mat_<_Tp>& m)
        -:  343:{ init(FIXED_TYPE + MAT + traits::Type<_Tp>::value + ACCESS_RW, &m); }
        -:  344:
        -:  345:template<typename _Tp, int m, int n> inline
        -:  346:_InputOutputArray::_InputOutputArray(Matx<_Tp, m, n>& mtx)
        -:  347:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_RW, &mtx, Size(n, m)); }
        -:  348:
        -:  349:template<typename _Tp> inline
        -:  350:_InputOutputArray::_InputOutputArray(_Tp* vec, int n)
        -:  351:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_RW, vec, Size(n, 1)); }
        -:  352:
        -:  353:template<typename _Tp> inline
        -:  354:_InputOutputArray::_InputOutputArray(const std::vector<_Tp>& vec)
        -:  355:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR + traits::Type<_Tp>::value + ACCESS_RW, &vec); }
        -:  356:
        -:  357:template<typename _Tp, std::size_t _Nm> inline
        -:  358:_InputOutputArray::_InputOutputArray(const std::array<_Tp, _Nm>& arr)
        -:  359:{ init(FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_RW, arr.data(), Size(1, _Nm)); }
        -:  360:
        -:  361:template<std::size_t _Nm> inline
        -:  362:_InputOutputArray::_InputOutputArray(const std::array<Mat, _Nm>& arr)
        -:  363:{ init(FIXED_SIZE + STD_ARRAY_MAT + ACCESS_RW, arr.data(), Size(1, _Nm)); }
        -:  364:
        -:  365:template<typename _Tp> inline
        -:  366:_InputOutputArray::_InputOutputArray(const std::vector<std::vector<_Tp> >& vec)
        -:  367:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_VECTOR + traits::Type<_Tp>::value + ACCESS_RW, &vec); }
        -:  368:
        -:  369:template<typename _Tp> inline
        -:  370:_InputOutputArray::_InputOutputArray(const std::vector<Mat_<_Tp> >& vec)
        -:  371:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_MAT + traits::Type<_Tp>::value + ACCESS_RW, &vec); }
        -:  372:
        -:  373:template<typename _Tp> inline
        -:  374:_InputOutputArray::_InputOutputArray(const Mat_<_Tp>& m)
        -:  375:{ init(FIXED_TYPE + FIXED_SIZE + MAT + traits::Type<_Tp>::value + ACCESS_RW, &m); }
        -:  376:
        -:  377:template<typename _Tp, int m, int n> inline
        -:  378:_InputOutputArray::_InputOutputArray(const Matx<_Tp, m, n>& mtx)
        -:  379:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_RW, &mtx, Size(n, m)); }
        -:  380:
        -:  381:template<typename _Tp> inline
        -:  382:_InputOutputArray::_InputOutputArray(const _Tp* vec, int n)
        -:  383:{ init(FIXED_TYPE + FIXED_SIZE + MATX + traits::Type<_Tp>::value + ACCESS_RW, vec, Size(n, 1)); }
        -:  384:
        -:  385:inline _InputOutputArray::_InputOutputArray(cuda::GpuMat& d_mat)
        -:  386:{ init(CUDA_GPU_MAT + ACCESS_RW, &d_mat); }
        -:  387:
        -:  388:inline _InputOutputArray::_InputOutputArray(ogl::Buffer& buf)
        -:  389:{ init(OPENGL_BUFFER + ACCESS_RW, &buf); }
        -:  390:
        -:  391:inline _InputOutputArray::_InputOutputArray(cuda::HostMem& cuda_mem)
        -:  392:{ init(CUDA_HOST_MEM + ACCESS_RW, &cuda_mem); }
        -:  393:
        -:  394:inline _InputOutputArray::_InputOutputArray(const Mat& m)
        -:  395:{ init(FIXED_TYPE + FIXED_SIZE + MAT + ACCESS_RW, &m); }
        -:  396:
        -:  397:inline _InputOutputArray::_InputOutputArray(const std::vector<Mat>& vec)
        -:  398:{ init(FIXED_SIZE + STD_VECTOR_MAT + ACCESS_RW, &vec); }
        -:  399:
        -:  400:inline _InputOutputArray::_InputOutputArray(const UMat& m)
        -:  401:{ init(FIXED_TYPE + FIXED_SIZE + UMAT + ACCESS_RW, &m); }
        -:  402:
        -:  403:inline _InputOutputArray::_InputOutputArray(const std::vector<UMat>& vec)
        -:  404:{ init(FIXED_SIZE + STD_VECTOR_UMAT + ACCESS_RW, &vec); }
        -:  405:
        -:  406:inline _InputOutputArray::_InputOutputArray(const cuda::GpuMat& d_mat)
        -:  407:{ init(FIXED_TYPE + FIXED_SIZE + CUDA_GPU_MAT + ACCESS_RW, &d_mat); }
        -:  408:
        -:  409:inline _InputOutputArray::_InputOutputArray(const std::vector<cuda::GpuMat>& d_mat)
        -:  410:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_CUDA_GPU_MAT + ACCESS_RW, &d_mat);}
        -:  411:
        -:  412:template<> inline _InputOutputArray::_InputOutputArray(std::vector<cuda::GpuMat>& d_mat)
        -:  413:{ init(FIXED_TYPE + FIXED_SIZE + STD_VECTOR_CUDA_GPU_MAT + ACCESS_RW, &d_mat);}
        -:  414:
        -:  415:inline _InputOutputArray::_InputOutputArray(const ogl::Buffer& buf)
        -:  416:{ init(FIXED_TYPE + FIXED_SIZE + OPENGL_BUFFER + ACCESS_RW, &buf); }
        -:  417:
        -:  418:inline _InputOutputArray::_InputOutputArray(const cuda::HostMem& cuda_mem)
        -:  419:{ init(FIXED_TYPE + FIXED_SIZE + CUDA_HOST_MEM + ACCESS_RW, &cuda_mem); }
        -:  420:
        -:  421:template<typename _Tp> inline
        -:  422:_InputOutputArray _InputOutputArray::rawInOut(std::vector<_Tp>& vec)
        -:  423:{
        -:  424:    _InputOutputArray v;
        -:  425:    v.flags = _InputArray::FIXED_TYPE + _InputArray::STD_VECTOR + rawType<_Tp>() + ACCESS_RW;
        -:  426:    v.obj = (void*)&vec;
        -:  427:    return v;
        -:  428:}
        -:  429:
        -:  430:template<typename _Tp, std::size_t _Nm> inline
        -:  431:_InputOutputArray _InputOutputArray::rawInOut(std::array<_Tp, _Nm>& arr)
        -:  432:{
        -:  433:    _InputOutputArray v;
        -:  434:    v.flags = FIXED_TYPE + FIXED_SIZE + STD_ARRAY + traits::Type<_Tp>::value + ACCESS_RW;
        -:  435:    v.obj = (void*)arr.data();
        -:  436:    v.sz = Size(1, _Nm);
        -:  437:    return v;
        -:  438:}
        -:  439:
        -:  440:
        -:  441:template<typename _Tp> static inline _InputArray rawIn(_Tp& v) { return _InputArray::rawIn(v); }
        -:  442:template<typename _Tp> static inline _OutputArray rawOut(_Tp& v) { return _OutputArray::rawOut(v); }
        -:  443:template<typename _Tp> static inline _InputOutputArray rawInOut(_Tp& v) { return _InputOutputArray::rawInOut(v); }
        -:  444:
        -:  445:CV__DEBUG_NS_END
        -:  446:
        -:  447://////////////////////////////////////////// Mat //////////////////////////////////////////
        -:  448:
        -:  449:inline
        -:  450:Mat::Mat()
        -:  451:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  452:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  453:{}
        -:  454:
        -:  455:inline
        -:  456:Mat::Mat(int _rows, int _cols, int _type)
        -:  457:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  458:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  459:{
        -:  460:    create(_rows, _cols, _type);
        -:  461:}
        -:  462:
        -:  463:inline
        -:  464:Mat::Mat(int _rows, int _cols, int _type, const Scalar& _s)
        -:  465:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  466:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  467:{
        -:  468:    create(_rows, _cols, _type);
        -:  469:    *this = _s;
        -:  470:}
        -:  471:
        -:  472:inline
        -:  473:Mat::Mat(Size _sz, int _type)
        -:  474:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  475:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  476:{
        -:  477:    create( _sz.height, _sz.width, _type );
        -:  478:}
        -:  479:
        -:  480:inline
        -:  481:Mat::Mat(Size _sz, int _type, const Scalar& _s)
        -:  482:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  483:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  484:{
        -:  485:    create(_sz.height, _sz.width, _type);
        -:  486:    *this = _s;
        -:  487:}
        -:  488:
        -:  489:inline
        -:  490:Mat::Mat(int _dims, const int* _sz, int _type)
        -:  491:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  492:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  493:{
        -:  494:    create(_dims, _sz, _type);
        -:  495:}
        -:  496:
        -:  497:inline
        -:  498:Mat::Mat(int _dims, const int* _sz, int _type, const Scalar& _s)
        -:  499:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  500:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  501:{
        -:  502:    create(_dims, _sz, _type);
        -:  503:    *this = _s;
        -:  504:}
        -:  505:
        -:  506:inline
        -:  507:Mat::Mat(const std::vector<int>& _sz, int _type)
        -:  508:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  509:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  510:{
        -:  511:    create(_sz, _type);
        -:  512:}
        -:  513:
        -:  514:inline
        -:  515:Mat::Mat(const std::vector<int>& _sz, int _type, const Scalar& _s)
        -:  516:    : flags(MAGIC_VAL), dims(0), rows(0), cols(0), data(0), datastart(0), dataend(0),
        -:  517:      datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  518:{
        -:  519:    create(_sz, _type);
        -:  520:    *this = _s;
        -:  521:}
        -:  522:
        -:  523:inline
        -:  524:Mat::Mat(const Mat& m)
        -:  525:    : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), data(m.data),
        -:  526:      datastart(m.datastart), dataend(m.dataend), datalimit(m.datalimit), allocator(m.allocator),
        -:  527:      u(m.u), size(&rows), step(0)
        -:  528:{
        -:  529:    if( u )
        -:  530:        CV_XADD(&u->refcount, 1);
        -:  531:    if( m.dims <= 2 )
        -:  532:    {
        -:  533:        step[0] = m.step[0]; step[1] = m.step[1];
        -:  534:    }
        -:  535:    else
        -:  536:    {
        -:  537:        dims = 0;
        -:  538:        copySize(m);
        -:  539:    }
        -:  540:}
        -:  541:
        -:  542:inline
        -:  543:Mat::Mat(int _rows, int _cols, int _type, void* _data, size_t _step)
        -:  544:    : flags(MAGIC_VAL + (_type & TYPE_MASK)), dims(2), rows(_rows), cols(_cols),
        -:  545:      data((uchar*)_data), datastart((uchar*)_data), dataend(0), datalimit(0),
        -:  546:      allocator(0), u(0), size(&rows)
        -:  547:{
        -:  548:    CV_Assert(total() == 0 || data != NULL);
        -:  549:
        -:  550:    size_t esz = CV_ELEM_SIZE(_type), esz1 = CV_ELEM_SIZE1(_type);
        -:  551:    size_t minstep = cols * esz;
        -:  552:    if( _step == AUTO_STEP )
        -:  553:    {
        -:  554:        _step = minstep;
        -:  555:    }
        -:  556:    else
        -:  557:    {
        -:  558:        CV_DbgAssert( _step >= minstep );
        -:  559:        if (_step % esz1 != 0)
        -:  560:        {
        -:  561:            CV_Error(Error::BadStep, "Step must be a multiple of esz1");
        -:  562:        }
        -:  563:    }
        -:  564:    step[0] = _step;
        -:  565:    step[1] = esz;
        -:  566:    datalimit = datastart + _step * rows;
        -:  567:    dataend = datalimit - _step + minstep;
        -:  568:    updateContinuityFlag();
        -:  569:}
        -:  570:
        -:  571:inline
        -:  572:Mat::Mat(Size _sz, int _type, void* _data, size_t _step)
        -:  573:    : flags(MAGIC_VAL + (_type & TYPE_MASK)), dims(2), rows(_sz.height), cols(_sz.width),
        -:  574:      data((uchar*)_data), datastart((uchar*)_data), dataend(0), datalimit(0),
        -:  575:      allocator(0), u(0), size(&rows)
        -:  576:{
        -:  577:    CV_Assert(total() == 0 || data != NULL);
        -:  578:
        -:  579:    size_t esz = CV_ELEM_SIZE(_type), esz1 = CV_ELEM_SIZE1(_type);
        -:  580:    size_t minstep = cols*esz;
        -:  581:    if( _step == AUTO_STEP )
        -:  582:    {
        -:  583:        _step = minstep;
        -:  584:    }
        -:  585:    else
        -:  586:    {
        -:  587:        CV_DbgAssert( _step >= minstep );
        -:  588:
        -:  589:        if (_step % esz1 != 0)
        -:  590:        {
        -:  591:            CV_Error(Error::BadStep, "Step must be a multiple of esz1");
        -:  592:        }
        -:  593:    }
        -:  594:    step[0] = _step;
        -:  595:    step[1] = esz;
        -:  596:    datalimit = datastart + _step*rows;
        -:  597:    dataend = datalimit - _step + minstep;
        -:  598:    updateContinuityFlag();
        -:  599:}
        -:  600:
        -:  601:template<typename _Tp> inline
        -:  602:Mat::Mat(const std::vector<_Tp>& vec, bool copyData)
        -:  603:    : flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(2), rows((int)vec.size()),
        -:  604:      cols(1), data(0), datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  605:{
        -:  606:    if(vec.empty())
        -:  607:        return;
        -:  608:    if( !copyData )
        -:  609:    {
        -:  610:        step[0] = step[1] = sizeof(_Tp);
        -:  611:        datastart = data = (uchar*)&vec[0];
        -:  612:        datalimit = dataend = datastart + rows * step[0];
        -:  613:    }
        -:  614:    else
        -:  615:        Mat((int)vec.size(), 1, traits::Type<_Tp>::value, (uchar*)&vec[0]).copyTo(*this);
        -:  616:}
        -:  617:
        -:  618:template<typename _Tp, typename> inline
        -:  619:Mat::Mat(const std::initializer_list<_Tp> list)
        -:  620:    : Mat()
        -:  621:{
        -:  622:    CV_Assert(list.size() != 0);
        -:  623:    Mat((int)list.size(), 1, traits::Type<_Tp>::value, (uchar*)list.begin()).copyTo(*this);
        -:  624:}
        -:  625:
        -:  626:template<typename _Tp> inline
        -:  627:Mat::Mat(const std::initializer_list<int> sizes, const std::initializer_list<_Tp> list)
        -:  628:    : Mat()
        -:  629:{
        -:  630:    size_t size_total = 1;
        -:  631:    for(auto s : sizes)
        -:  632:        size_total *= s;
        -:  633:    CV_Assert(list.size() != 0);
        -:  634:    CV_Assert(size_total == list.size());
        -:  635:    Mat((int)sizes.size(), (int*)sizes.begin(), traits::Type<_Tp>::value, (uchar*)list.begin()).copyTo(*this);
        -:  636:}
        -:  637:
        -:  638:template<typename _Tp, std::size_t _Nm> inline
        -:  639:Mat::Mat(const std::array<_Tp, _Nm>& arr, bool copyData)
        -:  640:    : flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(2), rows((int)arr.size()),
        -:  641:      cols(1), data(0), datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  642:{
        -:  643:    if(arr.empty())
        -:  644:        return;
        -:  645:    if( !copyData )
        -:  646:    {
        -:  647:        step[0] = step[1] = sizeof(_Tp);
        -:  648:        datastart = data = (uchar*)arr.data();
        -:  649:        datalimit = dataend = datastart + rows * step[0];
        -:  650:    }
        -:  651:    else
        -:  652:        Mat((int)arr.size(), 1, traits::Type<_Tp>::value, (uchar*)arr.data()).copyTo(*this);
        -:  653:}
        -:  654:
        -:  655:template<typename _Tp, int n> inline
        -:  656:Mat::Mat(const Vec<_Tp, n>& vec, bool copyData)
        -:  657:    : flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(2), rows(n), cols(1), data(0),
        -:  658:      datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  659:{
        -:  660:    if( !copyData )
        -:  661:    {
        -:  662:        step[0] = step[1] = sizeof(_Tp);
        -:  663:        datastart = data = (uchar*)vec.val;
        -:  664:        datalimit = dataend = datastart + rows * step[0];
        -:  665:    }
        -:  666:    else
        -:  667:        Mat(n, 1, traits::Type<_Tp>::value, (void*)vec.val).copyTo(*this);
        -:  668:}
        -:  669:
        -:  670:
        -:  671:template<typename _Tp, int m, int n> inline
        -:  672:Mat::Mat(const Matx<_Tp,m,n>& M, bool copyData)
        -:  673:    : flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(2), rows(m), cols(n), data(0),
        -:  674:      datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  675:{
        -:  676:    if( !copyData )
        -:  677:    {
        -:  678:        step[0] = cols * sizeof(_Tp);
        -:  679:        step[1] = sizeof(_Tp);
        -:  680:        datastart = data = (uchar*)M.val;
        -:  681:        datalimit = dataend = datastart + rows * step[0];
        -:  682:    }
        -:  683:    else
        -:  684:        Mat(m, n, traits::Type<_Tp>::value, (uchar*)M.val).copyTo(*this);
        -:  685:}
        -:  686:
        -:  687:template<typename _Tp> inline
        -:  688:Mat::Mat(const Point_<_Tp>& pt, bool copyData)
        -:  689:    : flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(2), rows(2), cols(1), data(0),
        -:  690:      datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  691:{
        -:  692:    if( !copyData )
        -:  693:    {
        -:  694:        step[0] = step[1] = sizeof(_Tp);
        -:  695:        datastart = data = (uchar*)&pt.x;
        -:  696:        datalimit = dataend = datastart + rows * step[0];
        -:  697:    }
        -:  698:    else
        -:  699:    {
        -:  700:        create(2, 1, traits::Type<_Tp>::value);
        -:  701:        ((_Tp*)data)[0] = pt.x;
        -:  702:        ((_Tp*)data)[1] = pt.y;
        -:  703:    }
        -:  704:}
        -:  705:
        -:  706:template<typename _Tp> inline
        -:  707:Mat::Mat(const Point3_<_Tp>& pt, bool copyData)
        -:  708:    : flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(2), rows(3), cols(1), data(0),
        -:  709:      datastart(0), dataend(0), datalimit(0), allocator(0), u(0), size(&rows), step(0)
        -:  710:{
        -:  711:    if( !copyData )
        -:  712:    {
        -:  713:        step[0] = step[1] = sizeof(_Tp);
        -:  714:        datastart = data = (uchar*)&pt.x;
        -:  715:        datalimit = dataend = datastart + rows * step[0];
        -:  716:    }
        -:  717:    else
        -:  718:    {
        -:  719:        create(3, 1, traits::Type<_Tp>::value);
        -:  720:        ((_Tp*)data)[0] = pt.x;
        -:  721:        ((_Tp*)data)[1] = pt.y;
        -:  722:        ((_Tp*)data)[2] = pt.z;
        -:  723:    }
        -:  724:}
        -:  725:
        -:  726:template<typename _Tp> inline
        -:  727:Mat::Mat(const MatCommaInitializer_<_Tp>& commaInitializer)
        -:  728:    : flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(0), rows(0), cols(0), data(0),
        -:  729:      datastart(0), dataend(0), allocator(0), u(0), size(&rows)
        -:  730:{
        -:  731:    *this = commaInitializer.operator Mat_<_Tp>();
        -:  732:}
        -:  733:
        -:  734:inline
        -:  735:Mat::~Mat()
        -:  736:{
        -:  737:    release();
        -:  738:    if( step.p != step.buf )
        -:  739:        fastFree(step.p);
        -:  740:}
        -:  741:
        -:  742:inline
        -:  743:Mat& Mat::operator = (const Mat& m)
        -:  744:{
        -:  745:    if( this != &m )
        -:  746:    {
        -:  747:        if( m.u )
        -:  748:            CV_XADD(&m.u->refcount, 1);
        -:  749:        release();
        -:  750:        flags = m.flags;
        -:  751:        if( dims <= 2 && m.dims <= 2 )
        -:  752:        {
        -:  753:            dims = m.dims;
        -:  754:            rows = m.rows;
        -:  755:            cols = m.cols;
        -:  756:            step[0] = m.step[0];
        -:  757:            step[1] = m.step[1];
        -:  758:        }
        -:  759:        else
        -:  760:            copySize(m);
        -:  761:        data = m.data;
        -:  762:        datastart = m.datastart;
        -:  763:        dataend = m.dataend;
        -:  764:        datalimit = m.datalimit;
        -:  765:        allocator = m.allocator;
        -:  766:        u = m.u;
        -:  767:    }
        -:  768:    return *this;
        -:  769:}
        -:  770:
        -:  771:inline
        -:  772:Mat Mat::row(int y) const
        -:  773:{
        -:  774:    return Mat(*this, Range(y, y + 1), Range::all());
        -:  775:}
        -:  776:
        -:  777:inline
        -:  778:Mat Mat::col(int x) const
        -:  779:{
        -:  780:    return Mat(*this, Range::all(), Range(x, x + 1));
        -:  781:}
        -:  782:
        -:  783:inline
        -:  784:Mat Mat::rowRange(int startrow, int endrow) const
        -:  785:{
        -:  786:    return Mat(*this, Range(startrow, endrow), Range::all());
        -:  787:}
        -:  788:
        -:  789:inline
        -:  790:Mat Mat::rowRange(const Range& r) const
        -:  791:{
        -:  792:    return Mat(*this, r, Range::all());
        -:  793:}
        -:  794:
        -:  795:inline
        -:  796:Mat Mat::colRange(int startcol, int endcol) const
        -:  797:{
        -:  798:    return Mat(*this, Range::all(), Range(startcol, endcol));
        -:  799:}
        -:  800:
        -:  801:inline
        -:  802:Mat Mat::colRange(const Range& r) const
        -:  803:{
        -:  804:    return Mat(*this, Range::all(), r);
        -:  805:}
        -:  806:
        -:  807:inline
        -:  808:Mat Mat::clone() const
        -:  809:{
        -:  810:    Mat m;
        -:  811:    copyTo(m);
        -:  812:    return m;
        -:  813:}
        -:  814:
        -:  815:inline
        -:  816:void Mat::assignTo( Mat& m, int _type ) const
        -:  817:{
        -:  818:    if( _type < 0 )
        -:  819:        m = *this;
        -:  820:    else
        -:  821:        convertTo(m, _type);
        -:  822:}
        -:  823:
        -:  824:inline
        -:  825:void Mat::create(int _rows, int _cols, int _type)
        -:  826:{
        -:  827:    _type &= TYPE_MASK;
        -:  828:    if( dims <= 2 && rows == _rows && cols == _cols && type() == _type && data )
        -:  829:        return;
        -:  830:    int sz[] = {_rows, _cols};
        -:  831:    create(2, sz, _type);
        -:  832:}
        -:  833:
        -:  834:inline
        -:  835:void Mat::create(Size _sz, int _type)
        -:  836:{
        -:  837:    create(_sz.height, _sz.width, _type);
        -:  838:}
        -:  839:
        -:  840:inline
        -:  841:void Mat::addref()
        -:  842:{
        -:  843:    if( u )
        -:  844:        CV_XADD(&u->refcount, 1);
        -:  845:}
        -:  846:
        -:  847:inline
        -:  848:void Mat::release()
        -:  849:{
        -:  850:    if( u && CV_XADD(&u->refcount, -1) == 1 )
        -:  851:        deallocate();
        -:  852:    u = NULL;
        -:  853:    datastart = dataend = datalimit = data = 0;
        -:  854:    for(int i = 0; i < dims; i++)
        -:  855:        size.p[i] = 0;
        -:  856:#ifdef _DEBUG
        -:  857:    flags = MAGIC_VAL;
        -:  858:    dims = rows = cols = 0;
        -:  859:    if(step.p != step.buf)
        -:  860:    {
        -:  861:        fastFree(step.p);
        -:  862:        step.p = step.buf;
        -:  863:        size.p = &rows;
        -:  864:    }
        -:  865:#endif
        -:  866:}
        -:  867:
        -:  868:inline
        -:  869:Mat Mat::operator()( Range _rowRange, Range _colRange ) const
        -:  870:{
        -:  871:    return Mat(*this, _rowRange, _colRange);
        -:  872:}
        -:  873:
        -:  874:inline
        -:  875:Mat Mat::operator()( const Rect& roi ) const
        -:  876:{
        -:  877:    return Mat(*this, roi);
        -:  878:}
        -:  879:
        -:  880:inline
        -:  881:Mat Mat::operator()(const Range* ranges) const
        -:  882:{
        -:  883:    return Mat(*this, ranges);
        -:  884:}
        -:  885:
        -:  886:inline
        -:  887:Mat Mat::operator()(const std::vector<Range>& ranges) const
        -:  888:{
        -:  889:    return Mat(*this, ranges);
        -:  890:}
        -:  891:
        -:  892:inline
        -:  893:bool Mat::isContinuous() const
        -:  894:{
        -:  895:    return (flags & CONTINUOUS_FLAG) != 0;
        -:  896:}
        -:  897:
        -:  898:inline
        -:  899:bool Mat::isSubmatrix() const
        -:  900:{
        -:  901:    return (flags & SUBMATRIX_FLAG) != 0;
        -:  902:}
        -:  903:
        -:  904:inline
        -:  905:size_t Mat::elemSize() const
        -:  906:{
        -:  907:    size_t res = dims > 0 ? step.p[dims - 1] : 0;
        -:  908:    CV_DbgAssert(res != 0);
        -:  909:    return res;
        -:  910:}
        -:  911:
        -:  912:inline
        -:  913:size_t Mat::elemSize1() const
        -:  914:{
        -:  915:    return CV_ELEM_SIZE1(flags);
        -:  916:}
        -:  917:
        -:  918:inline
        -:  919:int Mat::type() const
        -:  920:{
        -:  921:    return CV_MAT_TYPE(flags);
        -:  922:}
        -:  923:
        -:  924:inline
        -:  925:int Mat::depth() const
        -:  926:{
        -:  927:    return CV_MAT_DEPTH(flags);
        -:  928:}
        -:  929:
        -:  930:inline
        -:  931:int Mat::channels() const
        -:  932:{
        -:  933:    return CV_MAT_CN(flags);
        -:  934:}
        -:  935:
        -:  936:inline
        -:  937:size_t Mat::step1(int i) const
        -:  938:{
        -:  939:    return step.p[i] / elemSize1();
        -:  940:}
        -:  941:
        -:  942:inline
        -:  943:bool Mat::empty() const
        -:  944:{
        -:  945:    return data == 0 || total() == 0 || dims == 0;
        -:  946:}
        -:  947:
        -:  948:inline
        -:  949:size_t Mat::total() const
        -:  950:{
        -:  951:    if( dims <= 2 )
        -:  952:        return (size_t)rows * cols;
        -:  953:    size_t p = 1;
        -:  954:    for( int i = 0; i < dims; i++ )
        -:  955:        p *= size[i];
        -:  956:    return p;
        -:  957:}
        -:  958:
        -:  959:inline
        -:  960:size_t Mat::total(int startDim, int endDim) const
        -:  961:{
        -:  962:    CV_Assert( 0 <= startDim && startDim <= endDim);
        -:  963:    size_t p = 1;
        -:  964:    int endDim_ = endDim <= dims ? endDim : dims;
        -:  965:    for( int i = startDim; i < endDim_; i++ )
        -:  966:        p *= size[i];
        -:  967:    return p;
        -:  968:}
        -:  969:
        -:  970:inline
        -:  971:uchar* Mat::ptr(int y)
        -:  972:{
        -:  973:    CV_DbgAssert( y == 0 || (data && dims >= 1 && (unsigned)y < (unsigned)size.p[0]) );
        -:  974:    return data + step.p[0] * y;
        -:  975:}
        -:  976:
        -:  977:inline
        -:  978:const uchar* Mat::ptr(int y) const
        -:  979:{
        -:  980:    CV_DbgAssert( y == 0 || (data && dims >= 1 && (unsigned)y < (unsigned)size.p[0]) );
        -:  981:    return data + step.p[0] * y;
        -:  982:}
        -:  983:
        -:  984:template<typename _Tp> inline
        -:  985:_Tp* Mat::ptr(int y)
        -:  986:{
        -:  987:    CV_DbgAssert( y == 0 || (data && dims >= 1 && (unsigned)y < (unsigned)size.p[0]) );
        1:  988:    return (_Tp*)(data + step.p[0] * y);
        -:  989:}
        -:  990:
        -:  991:template<typename _Tp> inline
        -:  992:const _Tp* Mat::ptr(int y) const
        -:  993:{
        -:  994:    CV_DbgAssert( y == 0 || (data && dims >= 1 && (unsigned)y < (unsigned)size.p[0]) );
        1:  995:    return (const _Tp*)(data + step.p[0] * y);
        -:  996:}
        -:  997:
        -:  998:inline
        -:  999:uchar* Mat::ptr(int i0, int i1)
        -: 1000:{
        -: 1001:    CV_DbgAssert(dims >= 2);
        -: 1002:    CV_DbgAssert(data);
        -: 1003:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1004:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1005:    return data + i0 * step.p[0] + i1 * step.p[1];
        -: 1006:}
        -: 1007:
        -: 1008:inline
        -: 1009:const uchar* Mat::ptr(int i0, int i1) const
        -: 1010:{
        -: 1011:    CV_DbgAssert(dims >= 2);
        -: 1012:    CV_DbgAssert(data);
        -: 1013:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1014:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1015:    return data + i0 * step.p[0] + i1 * step.p[1];
        -: 1016:}
        -: 1017:
        -: 1018:template<typename _Tp> inline
        -: 1019:_Tp* Mat::ptr(int i0, int i1)
        -: 1020:{
        -: 1021:    CV_DbgAssert(dims >= 2);
        -: 1022:    CV_DbgAssert(data);
        -: 1023:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1024:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1025:    return (_Tp*)(data + i0 * step.p[0] + i1 * step.p[1]);
        -: 1026:}
        -: 1027:
        -: 1028:template<typename _Tp> inline
        -: 1029:const _Tp* Mat::ptr(int i0, int i1) const
        -: 1030:{
        -: 1031:    CV_DbgAssert(dims >= 2);
        -: 1032:    CV_DbgAssert(data);
        -: 1033:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1034:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1035:    return (const _Tp*)(data + i0 * step.p[0] + i1 * step.p[1]);
        -: 1036:}
        -: 1037:
        -: 1038:inline
        -: 1039:uchar* Mat::ptr(int i0, int i1, int i2)
        -: 1040:{
        -: 1041:    CV_DbgAssert(dims >= 3);
        -: 1042:    CV_DbgAssert(data);
        -: 1043:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1044:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1045:    CV_DbgAssert((unsigned)i2 < (unsigned)size.p[2]);
        -: 1046:    return data + i0 * step.p[0] + i1 * step.p[1] + i2 * step.p[2];
        -: 1047:}
        -: 1048:
        -: 1049:inline
        -: 1050:const uchar* Mat::ptr(int i0, int i1, int i2) const
        -: 1051:{
        -: 1052:    CV_DbgAssert(dims >= 3);
        -: 1053:    CV_DbgAssert(data);
        -: 1054:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1055:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1056:    CV_DbgAssert((unsigned)i2 < (unsigned)size.p[2]);
        -: 1057:    return data + i0 * step.p[0] + i1 * step.p[1] + i2 * step.p[2];
        -: 1058:}
        -: 1059:
        -: 1060:template<typename _Tp> inline
        -: 1061:_Tp* Mat::ptr(int i0, int i1, int i2)
        -: 1062:{
        -: 1063:    CV_DbgAssert(dims >= 3);
        -: 1064:    CV_DbgAssert(data);
        -: 1065:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1066:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1067:    CV_DbgAssert((unsigned)i2 < (unsigned)size.p[2]);
        -: 1068:    return (_Tp*)(data + i0 * step.p[0] + i1 * step.p[1] + i2 * step.p[2]);
        -: 1069:}
        -: 1070:
        -: 1071:template<typename _Tp> inline
        -: 1072:const _Tp* Mat::ptr(int i0, int i1, int i2) const
        -: 1073:{
        -: 1074:    CV_DbgAssert(dims >= 3);
        -: 1075:    CV_DbgAssert(data);
        -: 1076:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1077:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1078:    CV_DbgAssert((unsigned)i2 < (unsigned)size.p[2]);
        -: 1079:    return (const _Tp*)(data + i0 * step.p[0] + i1 * step.p[1] + i2 * step.p[2]);
        -: 1080:}
        -: 1081:
        -: 1082:inline
        -: 1083:uchar* Mat::ptr(const int* idx)
        -: 1084:{
        -: 1085:    int i, d = dims;
        -: 1086:    uchar* p = data;
        -: 1087:    CV_DbgAssert( d >= 1 && p );
        -: 1088:    for( i = 0; i < d; i++ )
        -: 1089:    {
        -: 1090:        CV_DbgAssert( (unsigned)idx[i] < (unsigned)size.p[i] );
        -: 1091:        p += idx[i] * step.p[i];
        -: 1092:    }
        -: 1093:    return p;
        -: 1094:}
        -: 1095:
        -: 1096:inline
        -: 1097:const uchar* Mat::ptr(const int* idx) const
        -: 1098:{
        -: 1099:    int i, d = dims;
        -: 1100:    uchar* p = data;
        -: 1101:    CV_DbgAssert( d >= 1 && p );
        -: 1102:    for( i = 0; i < d; i++ )
        -: 1103:    {
        -: 1104:        CV_DbgAssert( (unsigned)idx[i] < (unsigned)size.p[i] );
        -: 1105:        p += idx[i] * step.p[i];
        -: 1106:    }
        -: 1107:    return p;
        -: 1108:}
        -: 1109:
        -: 1110:template<typename _Tp> inline
        -: 1111:_Tp* Mat::ptr(const int* idx)
        -: 1112:{
        -: 1113:    int i, d = dims;
        -: 1114:    uchar* p = data;
        -: 1115:    CV_DbgAssert( d >= 1 && p );
        -: 1116:    for( i = 0; i < d; i++ )
        -: 1117:    {
        -: 1118:        CV_DbgAssert( (unsigned)idx[i] < (unsigned)size.p[i] );
        -: 1119:        p += idx[i] * step.p[i];
        -: 1120:    }
        -: 1121:    return (_Tp*)p;
        -: 1122:}
        -: 1123:
        -: 1124:template<typename _Tp> inline
        -: 1125:const _Tp* Mat::ptr(const int* idx) const
        -: 1126:{
        -: 1127:    int i, d = dims;
        -: 1128:    uchar* p = data;
        -: 1129:    CV_DbgAssert( d >= 1 && p );
        -: 1130:    for( i = 0; i < d; i++ )
        -: 1131:    {
        -: 1132:        CV_DbgAssert( (unsigned)idx[i] < (unsigned)size.p[i] );
        -: 1133:        p += idx[i] * step.p[i];
        -: 1134:    }
        -: 1135:    return (const _Tp*)p;
        -: 1136:}
        -: 1137:
        -: 1138:template<typename _Tp> inline
        -: 1139:_Tp& Mat::at(int i0, int i1)
        -: 1140:{
        -: 1141:    CV_DbgAssert(dims <= 2);
        -: 1142:    CV_DbgAssert(data);
        -: 1143:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1144:    CV_DbgAssert((unsigned)(i1 * DataType<_Tp>::channels) < (unsigned)(size.p[1] * channels()));
        -: 1145:    CV_DbgAssert(CV_ELEM_SIZE1(traits::Depth<_Tp>::value) == elemSize1());
        -: 1146:    return ((_Tp*)(data + step.p[0] * i0))[i1];
        -: 1147:}
        -: 1148:
        -: 1149:template<typename _Tp> inline
        -: 1150:const _Tp& Mat::at(int i0, int i1) const
        -: 1151:{
        -: 1152:    CV_DbgAssert(dims <= 2);
        -: 1153:    CV_DbgAssert(data);
        -: 1154:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1155:    CV_DbgAssert((unsigned)(i1 * DataType<_Tp>::channels) < (unsigned)(size.p[1] * channels()));
        -: 1156:    CV_DbgAssert(CV_ELEM_SIZE1(traits::Depth<_Tp>::value) == elemSize1());
        -: 1157:    return ((const _Tp*)(data + step.p[0] * i0))[i1];
        -: 1158:}
        -: 1159:
        -: 1160:template<typename _Tp> inline
        -: 1161:_Tp& Mat::at(Point pt)
        -: 1162:{
        -: 1163:    CV_DbgAssert(dims <= 2);
        -: 1164:    CV_DbgAssert(data);
        -: 1165:    CV_DbgAssert((unsigned)pt.y < (unsigned)size.p[0]);
        -: 1166:    CV_DbgAssert((unsigned)(pt.x * DataType<_Tp>::channels) < (unsigned)(size.p[1] * channels()));
        -: 1167:    CV_DbgAssert(CV_ELEM_SIZE1(traits::Depth<_Tp>::value) == elemSize1());
        -: 1168:    return ((_Tp*)(data + step.p[0] * pt.y))[pt.x];
        -: 1169:}
        -: 1170:
        -: 1171:template<typename _Tp> inline
        -: 1172:const _Tp& Mat::at(Point pt) const
        -: 1173:{
        -: 1174:    CV_DbgAssert(dims <= 2);
        -: 1175:    CV_DbgAssert(data);
        -: 1176:    CV_DbgAssert((unsigned)pt.y < (unsigned)size.p[0]);
        -: 1177:    CV_DbgAssert((unsigned)(pt.x * DataType<_Tp>::channels) < (unsigned)(size.p[1] * channels()));
        -: 1178:    CV_DbgAssert(CV_ELEM_SIZE1(traits::Depth<_Tp>::value) == elemSize1());
        -: 1179:    return ((const _Tp*)(data + step.p[0] * pt.y))[pt.x];
        -: 1180:}
        -: 1181:
        -: 1182:template<typename _Tp> inline
        -: 1183:_Tp& Mat::at(int i0)
        -: 1184:{
        -: 1185:    CV_DbgAssert(dims <= 2);
        -: 1186:    CV_DbgAssert(data);
        -: 1187:    CV_DbgAssert((unsigned)i0 < (unsigned)(size.p[0] * size.p[1]));
        -: 1188:    CV_DbgAssert(elemSize() == sizeof(_Tp));
        -: 1189:    if( isContinuous() || size.p[0] == 1 )
        -: 1190:        return ((_Tp*)data)[i0];
        -: 1191:    if( size.p[1] == 1 )
        -: 1192:        return *(_Tp*)(data + step.p[0] * i0);
        -: 1193:    int i = i0 / cols, j = i0 - i * cols;
        -: 1194:    return ((_Tp*)(data + step.p[0] * i))[j];
        -: 1195:}
        -: 1196:
        -: 1197:template<typename _Tp> inline
        -: 1198:const _Tp& Mat::at(int i0) const
        -: 1199:{
        -: 1200:    CV_DbgAssert(dims <= 2);
        -: 1201:    CV_DbgAssert(data);
        -: 1202:    CV_DbgAssert((unsigned)i0 < (unsigned)(size.p[0] * size.p[1]));
        -: 1203:    CV_DbgAssert(elemSize() == sizeof(_Tp));
        -: 1204:    if( isContinuous() || size.p[0] == 1 )
        -: 1205:        return ((const _Tp*)data)[i0];
        -: 1206:    if( size.p[1] == 1 )
        -: 1207:        return *(const _Tp*)(data + step.p[0] * i0);
        -: 1208:    int i = i0 / cols, j = i0 - i * cols;
        -: 1209:    return ((const _Tp*)(data + step.p[0] * i))[j];
        -: 1210:}
        -: 1211:
        -: 1212:template<typename _Tp> inline
        -: 1213:_Tp& Mat::at(int i0, int i1, int i2)
        -: 1214:{
        -: 1215:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1216:    return *(_Tp*)ptr(i0, i1, i2);
        -: 1217:}
        -: 1218:
        -: 1219:template<typename _Tp> inline
        -: 1220:const _Tp& Mat::at(int i0, int i1, int i2) const
        -: 1221:{
        -: 1222:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1223:    return *(const _Tp*)ptr(i0, i1, i2);
        -: 1224:}
        -: 1225:
        -: 1226:template<typename _Tp> inline
        -: 1227:_Tp& Mat::at(const int* idx)
        -: 1228:{
        -: 1229:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1230:    return *(_Tp*)ptr(idx);
        -: 1231:}
        -: 1232:
        -: 1233:template<typename _Tp> inline
        -: 1234:const _Tp& Mat::at(const int* idx) const
        -: 1235:{
        -: 1236:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1237:    return *(const _Tp*)ptr(idx);
        -: 1238:}
        -: 1239:
        -: 1240:template<typename _Tp, int n> inline
        -: 1241:_Tp& Mat::at(const Vec<int, n>& idx)
        -: 1242:{
        -: 1243:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1244:    return *(_Tp*)ptr(idx.val);
        -: 1245:}
        -: 1246:
        -: 1247:template<typename _Tp, int n> inline
        -: 1248:const _Tp& Mat::at(const Vec<int, n>& idx) const
        -: 1249:{
        -: 1250:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1251:    return *(const _Tp*)ptr(idx.val);
        -: 1252:}
        -: 1253:
        -: 1254:template<typename _Tp> inline
        -: 1255:MatConstIterator_<_Tp> Mat::begin() const
        -: 1256:{
        -: 1257:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1258:    return MatConstIterator_<_Tp>((const Mat_<_Tp>*)this);
        -: 1259:}
        -: 1260:
        -: 1261:template<typename _Tp> inline
        -: 1262:MatConstIterator_<_Tp> Mat::end() const
        -: 1263:{
        -: 1264:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1265:    MatConstIterator_<_Tp> it((const Mat_<_Tp>*)this);
        -: 1266:    it += total();
        -: 1267:    return it;
        -: 1268:}
        -: 1269:
        -: 1270:template<typename _Tp> inline
        -: 1271:MatIterator_<_Tp> Mat::begin()
        -: 1272:{
        -: 1273:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1274:    return MatIterator_<_Tp>((Mat_<_Tp>*)this);
        -: 1275:}
        -: 1276:
        -: 1277:template<typename _Tp> inline
        -: 1278:MatIterator_<_Tp> Mat::end()
        -: 1279:{
        -: 1280:    CV_DbgAssert( elemSize() == sizeof(_Tp) );
        -: 1281:    MatIterator_<_Tp> it((Mat_<_Tp>*)this);
        -: 1282:    it += total();
        -: 1283:    return it;
        -: 1284:}
        -: 1285:
        -: 1286:template<typename _Tp, typename Functor> inline
        -: 1287:void Mat::forEach(const Functor& operation) {
        -: 1288:    this->forEach_impl<_Tp>(operation);
        -: 1289:}
        -: 1290:
        -: 1291:template<typename _Tp, typename Functor> inline
        -: 1292:void Mat::forEach(const Functor& operation) const {
        -: 1293:    // call as not const
        -: 1294:    (const_cast<Mat*>(this))->forEach<_Tp>(operation);
        -: 1295:}
        -: 1296:
        -: 1297:template<typename _Tp> inline
        -: 1298:Mat::operator std::vector<_Tp>() const
        -: 1299:{
        -: 1300:    std::vector<_Tp> v;
        -: 1301:    copyTo(v);
        -: 1302:    return v;
        -: 1303:}
        -: 1304:
        -: 1305:template<typename _Tp, std::size_t _Nm> inline
        -: 1306:Mat::operator std::array<_Tp, _Nm>() const
        -: 1307:{
        -: 1308:    std::array<_Tp, _Nm> v;
        -: 1309:    copyTo(v);
        -: 1310:    return v;
        -: 1311:}
        -: 1312:
        -: 1313:template<typename _Tp, int n> inline
        -: 1314:Mat::operator Vec<_Tp, n>() const
        -: 1315:{
        -: 1316:    CV_Assert( data && dims <= 2 && (rows == 1 || cols == 1) &&
        -: 1317:               rows + cols - 1 == n && channels() == 1 );
        -: 1318:
        -: 1319:    if( isContinuous() && type() == traits::Type<_Tp>::value )
        -: 1320:        return Vec<_Tp, n>((_Tp*)data);
        -: 1321:    Vec<_Tp, n> v;
        -: 1322:    Mat tmp(rows, cols, traits::Type<_Tp>::value, v.val);
        -: 1323:    convertTo(tmp, tmp.type());
        -: 1324:    return v;
        -: 1325:}
        -: 1326:
        -: 1327:template<typename _Tp, int m, int n> inline
        -: 1328:Mat::operator Matx<_Tp, m, n>() const
        -: 1329:{
        -: 1330:    CV_Assert( data && dims <= 2 && rows == m && cols == n && channels() == 1 );
        -: 1331:
        -: 1332:    if( isContinuous() && type() == traits::Type<_Tp>::value )
        -: 1333:        return Matx<_Tp, m, n>((_Tp*)data);
        -: 1334:    Matx<_Tp, m, n> mtx;
        -: 1335:    Mat tmp(rows, cols, traits::Type<_Tp>::value, mtx.val);
        -: 1336:    convertTo(tmp, tmp.type());
        -: 1337:    return mtx;
        -: 1338:}
        -: 1339:
        -: 1340:template<typename _Tp> inline
        -: 1341:void Mat::push_back(const _Tp& elem)
        -: 1342:{
        -: 1343:    if( !data )
        -: 1344:    {
        -: 1345:        *this = Mat(1, 1, traits::Type<_Tp>::value, (void*)&elem).clone();
        -: 1346:        return;
        -: 1347:    }
        -: 1348:    CV_Assert(traits::Type<_Tp>::value == type() && cols == 1
        -: 1349:              /* && dims == 2 (cols == 1 implies dims == 2) */);
        -: 1350:    const uchar* tmp = dataend + step[0];
        -: 1351:    if( !isSubmatrix() && isContinuous() && tmp <= datalimit )
        -: 1352:    {
        -: 1353:        *(_Tp*)(data + (size.p[0]++) * step.p[0]) = elem;
        -: 1354:        dataend = tmp;
        -: 1355:    }
        -: 1356:    else
        -: 1357:        push_back_(&elem);
        -: 1358:}
        -: 1359:
        -: 1360:template<typename _Tp> inline
        -: 1361:void Mat::push_back(const Mat_<_Tp>& m)
        -: 1362:{
        -: 1363:    push_back((const Mat&)m);
        -: 1364:}
        -: 1365:
        -: 1366:template<> inline
        -: 1367:void Mat::push_back(const MatExpr& expr)
        -: 1368:{
        -: 1369:    push_back(static_cast<Mat>(expr));
        -: 1370:}
        -: 1371:
        -: 1372:
        -: 1373:template<typename _Tp> inline
        -: 1374:void Mat::push_back(const std::vector<_Tp>& v)
        -: 1375:{
        -: 1376:    push_back(Mat(v));
        -: 1377:}
        -: 1378:
        -: 1379:inline
        -: 1380:Mat::Mat(Mat&& m)
        -: 1381:    : flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), data(m.data),
        -: 1382:      datastart(m.datastart), dataend(m.dataend), datalimit(m.datalimit), allocator(m.allocator),
        -: 1383:      u(m.u), size(&rows)
        -: 1384:{
        -: 1385:    if (m.dims <= 2)  // move new step/size info
        -: 1386:    {
        -: 1387:        step[0] = m.step[0];
        -: 1388:        step[1] = m.step[1];
        -: 1389:    }
        -: 1390:    else
        -: 1391:    {
        -: 1392:        CV_DbgAssert(m.step.p != m.step.buf);
        -: 1393:        step.p = m.step.p;
        -: 1394:        size.p = m.size.p;
        -: 1395:        m.step.p = m.step.buf;
        -: 1396:        m.size.p = &m.rows;
        -: 1397:    }
        -: 1398:    m.flags = MAGIC_VAL; m.dims = m.rows = m.cols = 0;
        -: 1399:    m.data = NULL; m.datastart = NULL; m.dataend = NULL; m.datalimit = NULL;
        -: 1400:    m.allocator = NULL;
        -: 1401:    m.u = NULL;
        -: 1402:}
        -: 1403:
        -: 1404:inline
        -: 1405:Mat& Mat::operator = (Mat&& m)
        -: 1406:{
        -: 1407:    if (this == &m)
        -: 1408:      return *this;
        -: 1409:
        -: 1410:    release();
        -: 1411:    flags = m.flags; dims = m.dims; rows = m.rows; cols = m.cols; data = m.data;
        -: 1412:    datastart = m.datastart; dataend = m.dataend; datalimit = m.datalimit; allocator = m.allocator;
        -: 1413:    u = m.u;
        -: 1414:    if (step.p != step.buf) // release self step/size
        -: 1415:    {
        -: 1416:        fastFree(step.p);
        -: 1417:        step.p = step.buf;
        -: 1418:        size.p = &rows;
        -: 1419:    }
        -: 1420:    if (m.dims <= 2) // move new step/size info
        -: 1421:    {
        -: 1422:        step[0] = m.step[0];
        -: 1423:        step[1] = m.step[1];
        -: 1424:    }
        -: 1425:    else
        -: 1426:    {
        -: 1427:        CV_DbgAssert(m.step.p != m.step.buf);
        -: 1428:        step.p = m.step.p;
        -: 1429:        size.p = m.size.p;
        -: 1430:        m.step.p = m.step.buf;
        -: 1431:        m.size.p = &m.rows;
        -: 1432:    }
        -: 1433:    m.flags = MAGIC_VAL; m.dims = m.rows = m.cols = 0;
        -: 1434:    m.data = NULL; m.datastart = NULL; m.dataend = NULL; m.datalimit = NULL;
        -: 1435:    m.allocator = NULL;
        -: 1436:    m.u = NULL;
        -: 1437:    return *this;
        -: 1438:}
        -: 1439:
        -: 1440:
        -: 1441:///////////////////////////// MatSize ////////////////////////////
        -: 1442:
        -: 1443:inline
        -: 1444:MatSize::MatSize(int* _p)
        -: 1445:    : p(_p) {}
        -: 1446:
        -: 1447:inline
        -: 1448:int MatSize::dims() const
        -: 1449:{
        -: 1450:    return (p - 1)[0];
        -: 1451:}
        -: 1452:
        -: 1453:inline
        -: 1454:Size MatSize::operator()() const
        -: 1455:{
        -: 1456:    CV_DbgAssert(dims() <= 2);
        -: 1457:    return Size(p[1], p[0]);
        -: 1458:}
        -: 1459:
        -: 1460:inline
        -: 1461:const int& MatSize::operator[](int i) const
        -: 1462:{
        -: 1463:    CV_DbgAssert(i < dims());
        -: 1464:#ifdef __OPENCV_BUILD
        -: 1465:    CV_DbgAssert(i >= 0);
        -: 1466:#endif
        -: 1467:    return p[i];
        -: 1468:}
        -: 1469:
        -: 1470:inline
        -: 1471:int& MatSize::operator[](int i)
        -: 1472:{
        -: 1473:    CV_DbgAssert(i < dims());
        -: 1474:#ifdef __OPENCV_BUILD
        -: 1475:    CV_DbgAssert(i >= 0);
        -: 1476:#endif
        -: 1477:    return p[i];
        -: 1478:}
        -: 1479:
        -: 1480:inline
        -: 1481:MatSize::operator const int*() const
        -: 1482:{
        -: 1483:    return p;
        -: 1484:}
        -: 1485:
        -: 1486:inline
        -: 1487:bool MatSize::operator == (const MatSize& sz) const
        -: 1488:{
        -: 1489:    int d = dims();
        -: 1490:    int dsz = sz.dims();
        -: 1491:    if( d != dsz )
        -: 1492:        return false;
        -: 1493:    if( d == 2 )
        -: 1494:        return p[0] == sz.p[0] && p[1] == sz.p[1];
        -: 1495:
        -: 1496:    for( int i = 0; i < d; i++ )
        -: 1497:        if( p[i] != sz.p[i] )
        -: 1498:            return false;
        -: 1499:    return true;
        -: 1500:}
        -: 1501:
        -: 1502:inline
        -: 1503:bool MatSize::operator != (const MatSize& sz) const
        -: 1504:{
        -: 1505:    return !(*this == sz);
        -: 1506:}
        -: 1507:
        -: 1508:
        -: 1509:
        -: 1510:///////////////////////////// MatStep ////////////////////////////
        -: 1511:
        -: 1512:inline
        -: 1513:MatStep::MatStep()
        -: 1514:{
        -: 1515:    p = buf; p[0] = p[1] = 0;
        -: 1516:}
        -: 1517:
        -: 1518:inline
        -: 1519:MatStep::MatStep(size_t s)
        -: 1520:{
        -: 1521:    p = buf; p[0] = s; p[1] = 0;
        -: 1522:}
        -: 1523:
        -: 1524:inline
        -: 1525:const size_t& MatStep::operator[](int i) const
        -: 1526:{
        -: 1527:    return p[i];
        -: 1528:}
        -: 1529:
        -: 1530:inline
        -: 1531:size_t& MatStep::operator[](int i)
        -: 1532:{
        -: 1533:    return p[i];
        -: 1534:}
        -: 1535:
        -: 1536:inline MatStep::operator size_t() const
        -: 1537:{
        -: 1538:    CV_DbgAssert( p == buf );
        -: 1539:    return buf[0];
        -: 1540:}
        -: 1541:
        -: 1542:inline MatStep& MatStep::operator = (size_t s)
        -: 1543:{
        -: 1544:    CV_DbgAssert( p == buf );
        -: 1545:    buf[0] = s;
        -: 1546:    return *this;
        -: 1547:}
        -: 1548:
        -: 1549:
        -: 1550:
        -: 1551:////////////////////////////// Mat_<_Tp> ////////////////////////////
        -: 1552:
        -: 1553:template<typename _Tp> inline
        -: 1554:Mat_<_Tp>::Mat_()
        -: 1555:    : Mat()
        -: 1556:{
        -: 1557:    flags = (flags & ~CV_MAT_TYPE_MASK) + traits::Type<_Tp>::value;
        -: 1558:}
        -: 1559:
        -: 1560:template<typename _Tp> inline
        -: 1561:Mat_<_Tp>::Mat_(int _rows, int _cols)
        -: 1562:    : Mat(_rows, _cols, traits::Type<_Tp>::value)
        -: 1563:{
        -: 1564:}
        -: 1565:
        -: 1566:template<typename _Tp> inline
        -: 1567:Mat_<_Tp>::Mat_(int _rows, int _cols, const _Tp& value)
        -: 1568:    : Mat(_rows, _cols, traits::Type<_Tp>::value)
        -: 1569:{
        -: 1570:    *this = value;
        -: 1571:}
        -: 1572:
        -: 1573:template<typename _Tp> inline
        -: 1574:Mat_<_Tp>::Mat_(Size _sz)
        -: 1575:    : Mat(_sz.height, _sz.width, traits::Type<_Tp>::value)
        -: 1576:{}
        -: 1577:
        -: 1578:template<typename _Tp> inline
        -: 1579:Mat_<_Tp>::Mat_(Size _sz, const _Tp& value)
        -: 1580:    : Mat(_sz.height, _sz.width, traits::Type<_Tp>::value)
        -: 1581:{
        -: 1582:    *this = value;
        -: 1583:}
        -: 1584:
        -: 1585:template<typename _Tp> inline
        -: 1586:Mat_<_Tp>::Mat_(int _dims, const int* _sz)
        -: 1587:    : Mat(_dims, _sz, traits::Type<_Tp>::value)
        -: 1588:{}
        -: 1589:
        -: 1590:template<typename _Tp> inline
        -: 1591:Mat_<_Tp>::Mat_(int _dims, const int* _sz, const _Tp& _s)
        -: 1592:    : Mat(_dims, _sz, traits::Type<_Tp>::value, Scalar(_s))
        -: 1593:{}
        -: 1594:
        -: 1595:template<typename _Tp> inline
        -: 1596:Mat_<_Tp>::Mat_(int _dims, const int* _sz, _Tp* _data, const size_t* _steps)
        -: 1597:    : Mat(_dims, _sz, traits::Type<_Tp>::value, _data, _steps)
        -: 1598:{}
        -: 1599:
        -: 1600:template<typename _Tp> inline
        -: 1601:Mat_<_Tp>::Mat_(const Mat_<_Tp>& m, const Range* ranges)
        -: 1602:    : Mat(m, ranges)
        -: 1603:{}
        -: 1604:
        -: 1605:template<typename _Tp> inline
        -: 1606:Mat_<_Tp>::Mat_(const Mat_<_Tp>& m, const std::vector<Range>& ranges)
        -: 1607:    : Mat(m, ranges)
        -: 1608:{}
        -: 1609:
        -: 1610:template<typename _Tp> inline
        -: 1611:Mat_<_Tp>::Mat_(const Mat& m)
        -: 1612:    : Mat()
        -: 1613:{
        -: 1614:    flags = (flags & ~CV_MAT_TYPE_MASK) + traits::Type<_Tp>::value;
        -: 1615:    *this = m;
        -: 1616:}
        -: 1617:
        -: 1618:template<typename _Tp> inline
        -: 1619:Mat_<_Tp>::Mat_(const Mat_& m)
        -: 1620:    : Mat(m)
        -: 1621:{}
        -: 1622:
        -: 1623:template<typename _Tp> inline
        -: 1624:Mat_<_Tp>::Mat_(int _rows, int _cols, _Tp* _data, size_t steps)
        -: 1625:    : Mat(_rows, _cols, traits::Type<_Tp>::value, _data, steps)
        -: 1626:{}
        -: 1627:
        -: 1628:template<typename _Tp> inline
        -: 1629:Mat_<_Tp>::Mat_(const Mat_& m, const Range& _rowRange, const Range& _colRange)
        -: 1630:    : Mat(m, _rowRange, _colRange)
        -: 1631:{}
        -: 1632:
        -: 1633:template<typename _Tp> inline
        -: 1634:Mat_<_Tp>::Mat_(const Mat_& m, const Rect& roi)
        -: 1635:    : Mat(m, roi)
        -: 1636:{}
        -: 1637:
        -: 1638:template<typename _Tp> template<int n> inline
        -: 1639:Mat_<_Tp>::Mat_(const Vec<typename DataType<_Tp>::channel_type, n>& vec, bool copyData)
        -: 1640:    : Mat(n / DataType<_Tp>::channels, 1, traits::Type<_Tp>::value, (void*)&vec)
        -: 1641:{
        -: 1642:    CV_Assert(n%DataType<_Tp>::channels == 0);
        -: 1643:    if( copyData )
        -: 1644:        *this = clone();
        -: 1645:}
        -: 1646:
        -: 1647:template<typename _Tp> template<int m, int n> inline
        -: 1648:Mat_<_Tp>::Mat_(const Matx<typename DataType<_Tp>::channel_type, m, n>& M, bool copyData)
        -: 1649:    : Mat(m, n / DataType<_Tp>::channels, traits::Type<_Tp>::value, (void*)&M)
        -: 1650:{
        -: 1651:    CV_Assert(n % DataType<_Tp>::channels == 0);
        -: 1652:    if( copyData )
        -: 1653:        *this = clone();
        -: 1654:}
        -: 1655:
        -: 1656:template<typename _Tp> inline
        -: 1657:Mat_<_Tp>::Mat_(const Point_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
        -: 1658:    : Mat(2 / DataType<_Tp>::channels, 1, traits::Type<_Tp>::value, (void*)&pt)
        -: 1659:{
        -: 1660:    CV_Assert(2 % DataType<_Tp>::channels == 0);
        -: 1661:    if( copyData )
        -: 1662:        *this = clone();
        -: 1663:}
        -: 1664:
        -: 1665:template<typename _Tp> inline
        -: 1666:Mat_<_Tp>::Mat_(const Point3_<typename DataType<_Tp>::channel_type>& pt, bool copyData)
        -: 1667:    : Mat(3 / DataType<_Tp>::channels, 1, traits::Type<_Tp>::value, (void*)&pt)
        -: 1668:{
        -: 1669:    CV_Assert(3 % DataType<_Tp>::channels == 0);
        -: 1670:    if( copyData )
        -: 1671:        *this = clone();
        -: 1672:}
        -: 1673:
        -: 1674:template<typename _Tp> inline
        -: 1675:Mat_<_Tp>::Mat_(const MatCommaInitializer_<_Tp>& commaInitializer)
        -: 1676:    : Mat(commaInitializer)
        -: 1677:{}
        -: 1678:
        -: 1679:template<typename _Tp> inline
        -: 1680:Mat_<_Tp>::Mat_(const std::vector<_Tp>& vec, bool copyData)
        -: 1681:    : Mat(vec, copyData)
        -: 1682:{}
        -: 1683:
        -: 1684:template<typename _Tp> inline
        -: 1685:Mat_<_Tp>::Mat_(std::initializer_list<_Tp> list)
        -: 1686:    : Mat(list)
        -: 1687:{}
        -: 1688:
        -: 1689:template<typename _Tp> inline
        -: 1690:Mat_<_Tp>::Mat_(const std::initializer_list<int> sizes, std::initializer_list<_Tp> list)
        -: 1691:    : Mat(sizes, list)
        -: 1692:{}
        -: 1693:
        -: 1694:template<typename _Tp> template<std::size_t _Nm> inline
        -: 1695:Mat_<_Tp>::Mat_(const std::array<_Tp, _Nm>& arr, bool copyData)
        -: 1696:    : Mat(arr, copyData)
        -: 1697:{}
        -: 1698:
        -: 1699:template<typename _Tp> inline
        -: 1700:Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat& m)
        -: 1701:{
        -: 1702:    if( traits::Type<_Tp>::value == m.type() )
        -: 1703:    {
        -: 1704:        Mat::operator = (m);
        -: 1705:        return *this;
        -: 1706:    }
        -: 1707:    if( traits::Depth<_Tp>::value == m.depth() )
        -: 1708:    {
        -: 1709:        return (*this = m.reshape(DataType<_Tp>::channels, m.dims, 0));
        -: 1710:    }
        -: 1711:    CV_Assert(DataType<_Tp>::channels == m.channels() || m.empty());
        -: 1712:    m.convertTo(*this, type());
        -: 1713:    return *this;
        -: 1714:}
        -: 1715:
        -: 1716:template<typename _Tp> inline
        -: 1717:Mat_<_Tp>& Mat_<_Tp>::operator = (const Mat_& m)
        -: 1718:{
        -: 1719:    Mat::operator=(m);
        -: 1720:    return *this;
        -: 1721:}
        -: 1722:
        -: 1723:template<typename _Tp> inline
        -: 1724:Mat_<_Tp>& Mat_<_Tp>::operator = (const _Tp& s)
        -: 1725:{
        -: 1726:    typedef typename DataType<_Tp>::vec_type VT;
        -: 1727:    Mat::operator=(Scalar((const VT&)s));
        -: 1728:    return *this;
        -: 1729:}
        -: 1730:
        -: 1731:template<typename _Tp> inline
        -: 1732:void Mat_<_Tp>::create(int _rows, int _cols)
        -: 1733:{
        -: 1734:    Mat::create(_rows, _cols, traits::Type<_Tp>::value);
        -: 1735:}
        -: 1736:
        -: 1737:template<typename _Tp> inline
        -: 1738:void Mat_<_Tp>::create(Size _sz)
        -: 1739:{
        -: 1740:    Mat::create(_sz, traits::Type<_Tp>::value);
        -: 1741:}
        -: 1742:
        -: 1743:template<typename _Tp> inline
        -: 1744:void Mat_<_Tp>::create(int _dims, const int* _sz)
        -: 1745:{
        -: 1746:    Mat::create(_dims, _sz, traits::Type<_Tp>::value);
        -: 1747:}
        -: 1748:
        -: 1749:template<typename _Tp> inline
        -: 1750:void Mat_<_Tp>::release()
        -: 1751:{
        -: 1752:    Mat::release();
        -: 1753:#ifdef _DEBUG
        -: 1754:    flags = (flags & ~CV_MAT_TYPE_MASK) + traits::Type<_Tp>::value;
        -: 1755:#endif
        -: 1756:}
        -: 1757:
        -: 1758:template<typename _Tp> inline
        -: 1759:Mat_<_Tp> Mat_<_Tp>::cross(const Mat_& m) const
        -: 1760:{
        -: 1761:    return Mat_<_Tp>(Mat::cross(m));
        -: 1762:}
        -: 1763:
        -: 1764:template<typename _Tp> template<typename T2> inline
        -: 1765:Mat_<_Tp>::operator Mat_<T2>() const
        -: 1766:{
        -: 1767:    return Mat_<T2>(*this);
        -: 1768:}
        -: 1769:
        -: 1770:template<typename _Tp> inline
        -: 1771:Mat_<_Tp> Mat_<_Tp>::row(int y) const
        -: 1772:{
        -: 1773:    return Mat_(*this, Range(y, y+1), Range::all());
        -: 1774:}
        -: 1775:
        -: 1776:template<typename _Tp> inline
        -: 1777:Mat_<_Tp> Mat_<_Tp>::col(int x) const
        -: 1778:{
        -: 1779:    return Mat_(*this, Range::all(), Range(x, x+1));
        -: 1780:}
        -: 1781:
        -: 1782:template<typename _Tp> inline
        -: 1783:Mat_<_Tp> Mat_<_Tp>::diag(int d) const
        -: 1784:{
        -: 1785:    return Mat_(Mat::diag(d));
        -: 1786:}
        -: 1787:
        -: 1788:template<typename _Tp> inline
        -: 1789:Mat_<_Tp> Mat_<_Tp>::clone() const
        -: 1790:{
        -: 1791:    return Mat_(Mat::clone());
        -: 1792:}
        -: 1793:
        -: 1794:template<typename _Tp> inline
        -: 1795:size_t Mat_<_Tp>::elemSize() const
        -: 1796:{
        -: 1797:    CV_DbgAssert( Mat::elemSize() == sizeof(_Tp) );
        -: 1798:    return sizeof(_Tp);
        -: 1799:}
        -: 1800:
        -: 1801:template<typename _Tp> inline
        -: 1802:size_t Mat_<_Tp>::elemSize1() const
        -: 1803:{
        -: 1804:    CV_DbgAssert( Mat::elemSize1() == sizeof(_Tp) / DataType<_Tp>::channels );
        -: 1805:    return sizeof(_Tp) / DataType<_Tp>::channels;
        -: 1806:}
        -: 1807:
        -: 1808:template<typename _Tp> inline
        -: 1809:int Mat_<_Tp>::type() const
        -: 1810:{
        -: 1811:    CV_DbgAssert( Mat::type() == traits::Type<_Tp>::value );
        -: 1812:    return traits::Type<_Tp>::value;
        -: 1813:}
        -: 1814:
        -: 1815:template<typename _Tp> inline
        -: 1816:int Mat_<_Tp>::depth() const
        -: 1817:{
        -: 1818:    CV_DbgAssert( Mat::depth() == traits::Depth<_Tp>::value );
        -: 1819:    return traits::Depth<_Tp>::value;
        -: 1820:}
        -: 1821:
        -: 1822:template<typename _Tp> inline
        -: 1823:int Mat_<_Tp>::channels() const
        -: 1824:{
        -: 1825:    CV_DbgAssert( Mat::channels() == DataType<_Tp>::channels );
        -: 1826:    return DataType<_Tp>::channels;
        -: 1827:}
        -: 1828:
        -: 1829:template<typename _Tp> inline
        -: 1830:size_t Mat_<_Tp>::stepT(int i) const
        -: 1831:{
        -: 1832:    return step.p[i] / elemSize();
        -: 1833:}
        -: 1834:
        -: 1835:template<typename _Tp> inline
        -: 1836:size_t Mat_<_Tp>::step1(int i) const
        -: 1837:{
        -: 1838:    return step.p[i] / elemSize1();
        -: 1839:}
        -: 1840:
        -: 1841:template<typename _Tp> inline
        -: 1842:Mat_<_Tp>& Mat_<_Tp>::adjustROI( int dtop, int dbottom, int dleft, int dright )
        -: 1843:{
        -: 1844:    return (Mat_<_Tp>&)(Mat::adjustROI(dtop, dbottom, dleft, dright));
        -: 1845:}
        -: 1846:
        -: 1847:template<typename _Tp> inline
        -: 1848:Mat_<_Tp> Mat_<_Tp>::operator()( const Range& _rowRange, const Range& _colRange ) const
        -: 1849:{
        -: 1850:    return Mat_<_Tp>(*this, _rowRange, _colRange);
        -: 1851:}
        -: 1852:
        -: 1853:template<typename _Tp> inline
        -: 1854:Mat_<_Tp> Mat_<_Tp>::operator()( const Rect& roi ) const
        -: 1855:{
        -: 1856:    return Mat_<_Tp>(*this, roi);
        -: 1857:}
        -: 1858:
        -: 1859:template<typename _Tp> inline
        -: 1860:Mat_<_Tp> Mat_<_Tp>::operator()( const Range* ranges ) const
        -: 1861:{
        -: 1862:    return Mat_<_Tp>(*this, ranges);
        -: 1863:}
        -: 1864:
        -: 1865:template<typename _Tp> inline
        -: 1866:Mat_<_Tp> Mat_<_Tp>::operator()(const std::vector<Range>& ranges) const
        -: 1867:{
        -: 1868:    return Mat_<_Tp>(*this, ranges);
        -: 1869:}
        -: 1870:
        -: 1871:template<typename _Tp> inline
        -: 1872:_Tp* Mat_<_Tp>::operator [](int y)
        -: 1873:{
        -: 1874:    CV_DbgAssert( 0 <= y && y < size.p[0] );
        -: 1875:    return (_Tp*)(data + y*step.p[0]);
        -: 1876:}
        -: 1877:
        -: 1878:template<typename _Tp> inline
        -: 1879:const _Tp* Mat_<_Tp>::operator [](int y) const
        -: 1880:{
        -: 1881:    CV_DbgAssert( 0 <= y && y < size.p[0] );
        -: 1882:    return (const _Tp*)(data + y*step.p[0]);
        -: 1883:}
        -: 1884:
        -: 1885:template<typename _Tp> inline
        -: 1886:_Tp& Mat_<_Tp>::operator ()(int i0, int i1)
        -: 1887:{
        -: 1888:    CV_DbgAssert(dims <= 2);
        -: 1889:    CV_DbgAssert(data);
        -: 1890:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1891:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1892:    CV_DbgAssert(type() == traits::Type<_Tp>::value);
        -: 1893:    return ((_Tp*)(data + step.p[0] * i0))[i1];
        -: 1894:}
        -: 1895:
        -: 1896:template<typename _Tp> inline
        -: 1897:const _Tp& Mat_<_Tp>::operator ()(int i0, int i1) const
        -: 1898:{
        -: 1899:    CV_DbgAssert(dims <= 2);
        -: 1900:    CV_DbgAssert(data);
        -: 1901:    CV_DbgAssert((unsigned)i0 < (unsigned)size.p[0]);
        -: 1902:    CV_DbgAssert((unsigned)i1 < (unsigned)size.p[1]);
        -: 1903:    CV_DbgAssert(type() == traits::Type<_Tp>::value);
        -: 1904:    return ((const _Tp*)(data + step.p[0] * i0))[i1];
        -: 1905:}
        -: 1906:
        -: 1907:template<typename _Tp> inline
        -: 1908:_Tp& Mat_<_Tp>::operator ()(Point pt)
        -: 1909:{
        -: 1910:    CV_DbgAssert(dims <= 2);
        -: 1911:    CV_DbgAssert(data);
        -: 1912:    CV_DbgAssert((unsigned)pt.y < (unsigned)size.p[0]);
        -: 1913:    CV_DbgAssert((unsigned)pt.x < (unsigned)size.p[1]);
        -: 1914:    CV_DbgAssert(type() == traits::Type<_Tp>::value);
        -: 1915:    return ((_Tp*)(data + step.p[0] * pt.y))[pt.x];
        -: 1916:}
        -: 1917:
        -: 1918:template<typename _Tp> inline
        -: 1919:const _Tp& Mat_<_Tp>::operator ()(Point pt) const
        -: 1920:{
        -: 1921:    CV_DbgAssert(dims <= 2);
        -: 1922:    CV_DbgAssert(data);
        -: 1923:    CV_DbgAssert((unsigned)pt.y < (unsigned)size.p[0]);
        -: 1924:    CV_DbgAssert((unsigned)pt.x < (unsigned)size.p[1]);
        -: 1925:    CV_DbgAssert(type() == traits::Type<_Tp>::value);
        -: 1926:    return ((const _Tp*)(data + step.p[0] * pt.y))[pt.x];
        -: 1927:}
        -: 1928:
        -: 1929:template<typename _Tp> inline
        -: 1930:_Tp& Mat_<_Tp>::operator ()(const int* idx)
        -: 1931:{
        -: 1932:    return Mat::at<_Tp>(idx);
        -: 1933:}
        -: 1934:
        -: 1935:template<typename _Tp> inline
        -: 1936:const _Tp& Mat_<_Tp>::operator ()(const int* idx) const
        -: 1937:{
        -: 1938:    return Mat::at<_Tp>(idx);
        -: 1939:}
        -: 1940:
        -: 1941:template<typename _Tp> template<int n> inline
        -: 1942:_Tp& Mat_<_Tp>::operator ()(const Vec<int, n>& idx)
        -: 1943:{
        -: 1944:    return Mat::at<_Tp>(idx);
        -: 1945:}
        -: 1946:
        -: 1947:template<typename _Tp> template<int n> inline
        -: 1948:const _Tp& Mat_<_Tp>::operator ()(const Vec<int, n>& idx) const
        -: 1949:{
        -: 1950:    return Mat::at<_Tp>(idx);
        -: 1951:}
        -: 1952:
        -: 1953:template<typename _Tp> inline
        -: 1954:_Tp& Mat_<_Tp>::operator ()(int i0)
        -: 1955:{
        -: 1956:    return this->at<_Tp>(i0);
        -: 1957:}
        -: 1958:
        -: 1959:template<typename _Tp> inline
        -: 1960:const _Tp& Mat_<_Tp>::operator ()(int i0) const
        -: 1961:{
        -: 1962:    return this->at<_Tp>(i0);
        -: 1963:}
        -: 1964:
        -: 1965:template<typename _Tp> inline
        -: 1966:_Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2)
        -: 1967:{
        -: 1968:    return this->at<_Tp>(i0, i1, i2);
        -: 1969:}
        -: 1970:
        -: 1971:template<typename _Tp> inline
        -: 1972:const _Tp& Mat_<_Tp>::operator ()(int i0, int i1, int i2) const
        -: 1973:{
        -: 1974:    return this->at<_Tp>(i0, i1, i2);
        -: 1975:}
        -: 1976:
        -: 1977:template<typename _Tp> inline
        -: 1978:Mat_<_Tp>::operator std::vector<_Tp>() const
        -: 1979:{
        -: 1980:    std::vector<_Tp> v;
        -: 1981:    copyTo(v);
        -: 1982:    return v;
        -: 1983:}
        -: 1984:
        -: 1985:template<typename _Tp> template<std::size_t _Nm> inline
        -: 1986:Mat_<_Tp>::operator std::array<_Tp, _Nm>() const
        -: 1987:{
        -: 1988:    std::array<_Tp, _Nm> a;
        -: 1989:    copyTo(a);
        -: 1990:    return a;
        -: 1991:}
        -: 1992:
        -: 1993:template<typename _Tp> template<int n> inline
        -: 1994:Mat_<_Tp>::operator Vec<typename DataType<_Tp>::channel_type, n>() const
        -: 1995:{
        -: 1996:    CV_Assert(n % DataType<_Tp>::channels == 0);
        -: 1997:
        -: 1998:#if defined _MSC_VER
        -: 1999:    const Mat* pMat = (const Mat*)this; // workaround for MSVS <= 2012 compiler bugs (but GCC 4.6 dislikes this workaround)
        -: 2000:    return pMat->operator Vec<typename DataType<_Tp>::channel_type, n>();
        -: 2001:#else
        -: 2002:    return this->Mat::operator Vec<typename DataType<_Tp>::channel_type, n>();
        -: 2003:#endif
        -: 2004:}
        -: 2005:
        -: 2006:template<typename _Tp> template<int m, int n> inline
        -: 2007:Mat_<_Tp>::operator Matx<typename DataType<_Tp>::channel_type, m, n>() const
        -: 2008:{
        -: 2009:    CV_Assert(n % DataType<_Tp>::channels == 0);
        -: 2010:
        -: 2011:#if defined _MSC_VER
        -: 2012:    const Mat* pMat = (const Mat*)this; // workaround for MSVS <= 2012 compiler bugs (but GCC 4.6 dislikes this workaround)
        -: 2013:    Matx<typename DataType<_Tp>::channel_type, m, n> res = pMat->operator Matx<typename DataType<_Tp>::channel_type, m, n>();
        -: 2014:    return res;
        -: 2015:#else
        -: 2016:    Matx<typename DataType<_Tp>::channel_type, m, n> res = this->Mat::operator Matx<typename DataType<_Tp>::channel_type, m, n>();
        -: 2017:    return res;
        -: 2018:#endif
        -: 2019:}
        -: 2020:
        -: 2021:template<typename _Tp> inline
        -: 2022:MatConstIterator_<_Tp> Mat_<_Tp>::begin() const
        -: 2023:{
        -: 2024:    return Mat::begin<_Tp>();
        -: 2025:}
        -: 2026:
        -: 2027:template<typename _Tp> inline
        -: 2028:MatConstIterator_<_Tp> Mat_<_Tp>::end() const
        -: 2029:{
        -: 2030:    return Mat::end<_Tp>();
        -: 2031:}
        -: 2032:
        -: 2033:template<typename _Tp> inline
        -: 2034:MatIterator_<_Tp> Mat_<_Tp>::begin()
        -: 2035:{
        -: 2036:    return Mat::begin<_Tp>();
        -: 2037:}
        -: 2038:
        -: 2039:template<typename _Tp> inline
        -: 2040:MatIterator_<_Tp> Mat_<_Tp>::end()
        -: 2041:{
        -: 2042:    return Mat::end<_Tp>();
        -: 2043:}
        -: 2044:
        -: 2045:template<typename _Tp> template<typename Functor> inline
        -: 2046:void Mat_<_Tp>::forEach(const Functor& operation) {
        -: 2047:    Mat::forEach<_Tp, Functor>(operation);
        -: 2048:}
        -: 2049:
        -: 2050:template<typename _Tp> template<typename Functor> inline
        -: 2051:void Mat_<_Tp>::forEach(const Functor& operation) const {
        -: 2052:    Mat::forEach<_Tp, Functor>(operation);
        -: 2053:}
        -: 2054:
        -: 2055:template<typename _Tp> inline
        -: 2056:Mat_<_Tp>::Mat_(Mat_&& m)
        -: 2057:    : Mat(m)
        -: 2058:{
        -: 2059:}
        -: 2060:
        -: 2061:template<typename _Tp> inline
        -: 2062:Mat_<_Tp>& Mat_<_Tp>::operator = (Mat_&& m)
        -: 2063:{
        -: 2064:    Mat::operator = (std::move(m));
        -: 2065:    return *this;
        -: 2066:}
        -: 2067:
        -: 2068:template<typename _Tp> inline
        -: 2069:Mat_<_Tp>::Mat_(Mat&& m)
        -: 2070:    : Mat()
        -: 2071:{
        -: 2072:    flags = (flags & ~CV_MAT_TYPE_MASK) + traits::Type<_Tp>::value;
        -: 2073:    *this = m;
        -: 2074:}
        -: 2075:
        -: 2076:template<typename _Tp> inline
        -: 2077:Mat_<_Tp>& Mat_<_Tp>::operator = (Mat&& m)
        -: 2078:{
        -: 2079:    if( traits::Type<_Tp>::value == m.type() )
        -: 2080:    {
        -: 2081:        Mat::operator = ((Mat&&)m);
        -: 2082:        return *this;
        -: 2083:    }
        -: 2084:    if( traits::Depth<_Tp>::value == m.depth() )
        -: 2085:    {
        -: 2086:        Mat::operator = ((Mat&&)m.reshape(DataType<_Tp>::channels, m.dims, 0));
        -: 2087:        return *this;
        -: 2088:    }
        -: 2089:    CV_DbgAssert(DataType<_Tp>::channels == m.channels());
        -: 2090:    m.convertTo(*this, type());
        -: 2091:    return *this;
        -: 2092:}
        -: 2093:
        -: 2094:template<typename _Tp> inline
        -: 2095:Mat_<_Tp>::Mat_(MatExpr&& e)
        -: 2096:    : Mat()
        -: 2097:{
        -: 2098:    flags = (flags & ~CV_MAT_TYPE_MASK) + traits::Type<_Tp>::value;
        -: 2099:    *this = Mat(e);
        -: 2100:}
        -: 2101:
        -: 2102:
        -: 2103:///////////////////////////// SparseMat /////////////////////////////
        -: 2104:
        -: 2105:inline
        -: 2106:SparseMat::SparseMat()
        -: 2107:    : flags(MAGIC_VAL), hdr(0)
        -: 2108:{}
        -: 2109:
        -: 2110:inline
        -: 2111:SparseMat::SparseMat(int _dims, const int* _sizes, int _type)
        -: 2112:    : flags(MAGIC_VAL), hdr(0)
        -: 2113:{
        -: 2114:    create(_dims, _sizes, _type);
        -: 2115:}
        -: 2116:
        -: 2117:inline
        -: 2118:SparseMat::SparseMat(const SparseMat& m)
        -: 2119:    : flags(m.flags), hdr(m.hdr)
        -: 2120:{
        -: 2121:    addref();
        -: 2122:}
        -: 2123:
        -: 2124:inline
        -: 2125:SparseMat::~SparseMat()
        -: 2126:{
        -: 2127:    release();
        -: 2128:}
        -: 2129:
        -: 2130:inline
        -: 2131:SparseMat& SparseMat::operator = (const SparseMat& m)
        -: 2132:{
        -: 2133:    if( this != &m )
        -: 2134:    {
        -: 2135:        if( m.hdr )
        -: 2136:            CV_XADD(&m.hdr->refcount, 1);
        -: 2137:        release();
        -: 2138:        flags = m.flags;
        -: 2139:        hdr = m.hdr;
        -: 2140:    }
        -: 2141:    return *this;
        -: 2142:}
        -: 2143:
        -: 2144:inline
        -: 2145:SparseMat& SparseMat::operator = (const Mat& m)
        -: 2146:{
        -: 2147:    return (*this = SparseMat(m));
        -: 2148:}
        -: 2149:
        -: 2150:inline
        -: 2151:SparseMat SparseMat::clone() const
        -: 2152:{
        -: 2153:    SparseMat temp;
        -: 2154:    this->copyTo(temp);
        -: 2155:    return temp;
        -: 2156:}
        -: 2157:
        -: 2158:inline
        -: 2159:void SparseMat::assignTo( SparseMat& m, int _type ) const
        -: 2160:{
        -: 2161:    if( _type < 0 )
        -: 2162:        m = *this;
        -: 2163:    else
        -: 2164:        convertTo(m, _type);
        -: 2165:}
        -: 2166:
        -: 2167:inline
        -: 2168:void SparseMat::addref()
        -: 2169:{
        -: 2170:    if( hdr )
        -: 2171:        CV_XADD(&hdr->refcount, 1);
        -: 2172:}
        -: 2173:
        -: 2174:inline
        -: 2175:void SparseMat::release()
        -: 2176:{
        -: 2177:    if( hdr && CV_XADD(&hdr->refcount, -1) == 1 )
        -: 2178:        delete hdr;
        -: 2179:    hdr = 0;
        -: 2180:}
        -: 2181:
        -: 2182:inline
        -: 2183:size_t SparseMat::elemSize() const
        -: 2184:{
        -: 2185:    return CV_ELEM_SIZE(flags);
        -: 2186:}
        -: 2187:
        -: 2188:inline
        -: 2189:size_t SparseMat::elemSize1() const
        -: 2190:{
        -: 2191:    return CV_ELEM_SIZE1(flags);
        -: 2192:}
        -: 2193:
        -: 2194:inline
        -: 2195:int SparseMat::type() const
        -: 2196:{
        -: 2197:    return CV_MAT_TYPE(flags);
        -: 2198:}
        -: 2199:
        -: 2200:inline
        -: 2201:int SparseMat::depth() const
        -: 2202:{
        -: 2203:    return CV_MAT_DEPTH(flags);
        -: 2204:}
        -: 2205:
        -: 2206:inline
        -: 2207:int SparseMat::channels() const
        -: 2208:{
        -: 2209:    return CV_MAT_CN(flags);
        -: 2210:}
        -: 2211:
        -: 2212:inline
        -: 2213:const int* SparseMat::size() const
        -: 2214:{
        -: 2215:    return hdr ? hdr->size : 0;
        -: 2216:}
        -: 2217:
        -: 2218:inline
        -: 2219:int SparseMat::size(int i) const
        -: 2220:{
        -: 2221:    if( hdr )
        -: 2222:    {
        -: 2223:        CV_DbgAssert((unsigned)i < (unsigned)hdr->dims);
        -: 2224:        return hdr->size[i];
        -: 2225:    }
        -: 2226:    return 0;
        -: 2227:}
        -: 2228:
        -: 2229:inline
        -: 2230:int SparseMat::dims() const
        -: 2231:{
        -: 2232:    return hdr ? hdr->dims : 0;
        -: 2233:}
        -: 2234:
        -: 2235:inline
        -: 2236:size_t SparseMat::nzcount() const
        -: 2237:{
        -: 2238:    return hdr ? hdr->nodeCount : 0;
        -: 2239:}
        -: 2240:
        -: 2241:inline
        -: 2242:size_t SparseMat::hash(int i0) const
        -: 2243:{
        -: 2244:    return (size_t)i0;
        -: 2245:}
        -: 2246:
        -: 2247:inline
        -: 2248:size_t SparseMat::hash(int i0, int i1) const
        -: 2249:{
        -: 2250:    return (size_t)(unsigned)i0 * HASH_SCALE + (unsigned)i1;
        -: 2251:}
        -: 2252:
        -: 2253:inline
        -: 2254:size_t SparseMat::hash(int i0, int i1, int i2) const
        -: 2255:{
        -: 2256:    return ((size_t)(unsigned)i0 * HASH_SCALE + (unsigned)i1) * HASH_SCALE + (unsigned)i2;
        -: 2257:}
        -: 2258:
        -: 2259:inline
        -: 2260:size_t SparseMat::hash(const int* idx) const
        -: 2261:{
        -: 2262:    size_t h = (unsigned)idx[0];
        -: 2263:    if( !hdr )
        -: 2264:        return 0;
        -: 2265:    int d = hdr->dims;
        -: 2266:    for(int i = 1; i < d; i++ )
        -: 2267:        h = h * HASH_SCALE + (unsigned)idx[i];
        -: 2268:    return h;
        -: 2269:}
        -: 2270:
        -: 2271:template<typename _Tp> inline
        -: 2272:_Tp& SparseMat::ref(int i0, size_t* hashval)
        -: 2273:{
        -: 2274:    return *(_Tp*)((SparseMat*)this)->ptr(i0, true, hashval);
        -: 2275:}
        -: 2276:
        -: 2277:template<typename _Tp> inline
        -: 2278:_Tp& SparseMat::ref(int i0, int i1, size_t* hashval)
        -: 2279:{
        -: 2280:    return *(_Tp*)((SparseMat*)this)->ptr(i0, i1, true, hashval);
        -: 2281:}
        -: 2282:
        -: 2283:template<typename _Tp> inline
        -: 2284:_Tp& SparseMat::ref(int i0, int i1, int i2, size_t* hashval)
        -: 2285:{
        -: 2286:    return *(_Tp*)((SparseMat*)this)->ptr(i0, i1, i2, true, hashval);
        -: 2287:}
        -: 2288:
        -: 2289:template<typename _Tp> inline
        -: 2290:_Tp& SparseMat::ref(const int* idx, size_t* hashval)
        -: 2291:{
        -: 2292:    return *(_Tp*)((SparseMat*)this)->ptr(idx, true, hashval);
        -: 2293:}
        -: 2294:
        -: 2295:template<typename _Tp> inline
        -: 2296:_Tp SparseMat::value(int i0, size_t* hashval) const
        -: 2297:{
        -: 2298:    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, false, hashval);
        -: 2299:    return p ? *p : _Tp();
        -: 2300:}
        -: 2301:
        -: 2302:template<typename _Tp> inline
        -: 2303:_Tp SparseMat::value(int i0, int i1, size_t* hashval) const
        -: 2304:{
        -: 2305:    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, i1, false, hashval);
        -: 2306:    return p ? *p : _Tp();
        -: 2307:}
        -: 2308:
        -: 2309:template<typename _Tp> inline
        -: 2310:_Tp SparseMat::value(int i0, int i1, int i2, size_t* hashval) const
        -: 2311:{
        -: 2312:    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(i0, i1, i2, false, hashval);
        -: 2313:    return p ? *p : _Tp();
        -: 2314:}
        -: 2315:
        -: 2316:template<typename _Tp> inline
        -: 2317:_Tp SparseMat::value(const int* idx, size_t* hashval) const
        -: 2318:{
        -: 2319:    const _Tp* p = (const _Tp*)((SparseMat*)this)->ptr(idx, false, hashval);
        -: 2320:    return p ? *p : _Tp();
        -: 2321:}
        -: 2322:
        -: 2323:template<typename _Tp> inline
        -: 2324:const _Tp* SparseMat::find(int i0, size_t* hashval) const
        -: 2325:{
        -: 2326:    return (const _Tp*)((SparseMat*)this)->ptr(i0, false, hashval);
        -: 2327:}
        -: 2328:
        -: 2329:template<typename _Tp> inline
        -: 2330:const _Tp* SparseMat::find(int i0, int i1, size_t* hashval) const
        -: 2331:{
        -: 2332:    return (const _Tp*)((SparseMat*)this)->ptr(i0, i1, false, hashval);
        -: 2333:}
        -: 2334:
        -: 2335:template<typename _Tp> inline
        -: 2336:const _Tp* SparseMat::find(int i0, int i1, int i2, size_t* hashval) const
        -: 2337:{
        -: 2338:    return (const _Tp*)((SparseMat*)this)->ptr(i0, i1, i2, false, hashval);
        -: 2339:}
        -: 2340:
        -: 2341:template<typename _Tp> inline
        -: 2342:const _Tp* SparseMat::find(const int* idx, size_t* hashval) const
        -: 2343:{
        -: 2344:    return (const _Tp*)((SparseMat*)this)->ptr(idx, false, hashval);
        -: 2345:}
        -: 2346:
        -: 2347:template<typename _Tp> inline
        -: 2348:_Tp& SparseMat::value(Node* n)
        -: 2349:{
        -: 2350:    return *(_Tp*)((uchar*)n + hdr->valueOffset);
        -: 2351:}
        -: 2352:
        -: 2353:template<typename _Tp> inline
        -: 2354:const _Tp& SparseMat::value(const Node* n) const
        -: 2355:{
        -: 2356:    return *(const _Tp*)((const uchar*)n + hdr->valueOffset);
        -: 2357:}
        -: 2358:
        -: 2359:inline
        -: 2360:SparseMat::Node* SparseMat::node(size_t nidx)
        -: 2361:{
        -: 2362:    return (Node*)(void*)&hdr->pool[nidx];
        -: 2363:}
        -: 2364:
        -: 2365:inline
        -: 2366:const SparseMat::Node* SparseMat::node(size_t nidx) const
        -: 2367:{
        -: 2368:    return (const Node*)(const void*)&hdr->pool[nidx];
        -: 2369:}
        -: 2370:
        -: 2371:inline
        -: 2372:SparseMatIterator SparseMat::begin()
        -: 2373:{
        -: 2374:    return SparseMatIterator(this);
        -: 2375:}
        -: 2376:
        -: 2377:inline
        -: 2378:SparseMatConstIterator SparseMat::begin() const
        -: 2379:{
        -: 2380:    return SparseMatConstIterator(this);
        -: 2381:}
        -: 2382:
        -: 2383:inline
        -: 2384:SparseMatIterator SparseMat::end()
        -: 2385:{
        -: 2386:    SparseMatIterator it(this);
        -: 2387:    it.seekEnd();
        -: 2388:    return it;
        -: 2389:}
        -: 2390:
        -: 2391:inline
        -: 2392:SparseMatConstIterator SparseMat::end() const
        -: 2393:{
        -: 2394:    SparseMatConstIterator it(this);
        -: 2395:    it.seekEnd();
        -: 2396:    return it;
        -: 2397:}
        -: 2398:
        -: 2399:template<typename _Tp> inline
        -: 2400:SparseMatIterator_<_Tp> SparseMat::begin()
        -: 2401:{
        -: 2402:    return SparseMatIterator_<_Tp>(this);
        -: 2403:}
        -: 2404:
        -: 2405:template<typename _Tp> inline
        -: 2406:SparseMatConstIterator_<_Tp> SparseMat::begin() const
        -: 2407:{
        -: 2408:    return SparseMatConstIterator_<_Tp>(this);
        -: 2409:}
        -: 2410:
        -: 2411:template<typename _Tp> inline
        -: 2412:SparseMatIterator_<_Tp> SparseMat::end()
        -: 2413:{
        -: 2414:    SparseMatIterator_<_Tp> it(this);
        -: 2415:    it.seekEnd();
        -: 2416:    return it;
        -: 2417:}
        -: 2418:
        -: 2419:template<typename _Tp> inline
        -: 2420:SparseMatConstIterator_<_Tp> SparseMat::end() const
        -: 2421:{
        -: 2422:    SparseMatConstIterator_<_Tp> it(this);
        -: 2423:    it.seekEnd();
        -: 2424:    return it;
        -: 2425:}
        -: 2426:
        -: 2427:
        -: 2428:
        -: 2429:///////////////////////////// SparseMat_ ////////////////////////////
        -: 2430:
        -: 2431:template<typename _Tp> inline
        -: 2432:SparseMat_<_Tp>::SparseMat_()
        -: 2433:{
        -: 2434:    flags = MAGIC_VAL + traits::Type<_Tp>::value;
        -: 2435:}
        -: 2436:
        -: 2437:template<typename _Tp> inline
        -: 2438:SparseMat_<_Tp>::SparseMat_(int _dims, const int* _sizes)
        -: 2439:    : SparseMat(_dims, _sizes, traits::Type<_Tp>::value)
        -: 2440:{}
        -: 2441:
        -: 2442:template<typename _Tp> inline
        -: 2443:SparseMat_<_Tp>::SparseMat_(const SparseMat& m)
        -: 2444:{
        -: 2445:    if( m.type() == traits::Type<_Tp>::value )
        -: 2446:        *this = (const SparseMat_<_Tp>&)m;
        -: 2447:    else
        -: 2448:        m.convertTo(*this, traits::Type<_Tp>::value);
        -: 2449:}
        -: 2450:
        -: 2451:template<typename _Tp> inline
        -: 2452:SparseMat_<_Tp>::SparseMat_(const SparseMat_<_Tp>& m)
        -: 2453:{
        -: 2454:    this->flags = m.flags;
        -: 2455:    this->hdr = m.hdr;
        -: 2456:    if( this->hdr )
        -: 2457:        CV_XADD(&this->hdr->refcount, 1);
        -: 2458:}
        -: 2459:
        -: 2460:template<typename _Tp> inline
        -: 2461:SparseMat_<_Tp>::SparseMat_(const Mat& m)
        -: 2462:{
        -: 2463:    SparseMat sm(m);
        -: 2464:    *this = sm;
        -: 2465:}
        -: 2466:
        -: 2467:template<typename _Tp> inline
        -: 2468:SparseMat_<_Tp>& SparseMat_<_Tp>::operator = (const SparseMat_<_Tp>& m)
        -: 2469:{
        -: 2470:    if( this != &m )
        -: 2471:    {
        -: 2472:        if( m.hdr ) CV_XADD(&m.hdr->refcount, 1);
        -: 2473:        release();
        -: 2474:        flags = m.flags;
        -: 2475:        hdr = m.hdr;
        -: 2476:    }
        -: 2477:    return *this;
        -: 2478:}
        -: 2479:
        -: 2480:template<typename _Tp> inline
        -: 2481:SparseMat_<_Tp>& SparseMat_<_Tp>::operator = (const SparseMat& m)
        -: 2482:{
        -: 2483:    if( m.type() == traits::Type<_Tp>::value )
        -: 2484:        return (*this = (const SparseMat_<_Tp>&)m);
        -: 2485:    m.convertTo(*this, traits::Type<_Tp>::value);
        -: 2486:    return *this;
        -: 2487:}
        -: 2488:
        -: 2489:template<typename _Tp> inline
        -: 2490:SparseMat_<_Tp>& SparseMat_<_Tp>::operator = (const Mat& m)
        -: 2491:{
        -: 2492:    return (*this = SparseMat(m));
        -: 2493:}
        -: 2494:
        -: 2495:template<typename _Tp> inline
        -: 2496:SparseMat_<_Tp> SparseMat_<_Tp>::clone() const
        -: 2497:{
        -: 2498:    SparseMat_<_Tp> m;
        -: 2499:    this->copyTo(m);
        -: 2500:    return m;
        -: 2501:}
        -: 2502:
        -: 2503:template<typename _Tp> inline
        -: 2504:void SparseMat_<_Tp>::create(int _dims, const int* _sizes)
        -: 2505:{
        -: 2506:    SparseMat::create(_dims, _sizes, traits::Type<_Tp>::value);
        -: 2507:}
        -: 2508:
        -: 2509:template<typename _Tp> inline
        -: 2510:int SparseMat_<_Tp>::type() const
        -: 2511:{
        -: 2512:    return traits::Type<_Tp>::value;
        -: 2513:}
        -: 2514:
        -: 2515:template<typename _Tp> inline
        -: 2516:int SparseMat_<_Tp>::depth() const
        -: 2517:{
        -: 2518:    return traits::Depth<_Tp>::value;
        -: 2519:}
        -: 2520:
        -: 2521:template<typename _Tp> inline
        -: 2522:int SparseMat_<_Tp>::channels() const
        -: 2523:{
        -: 2524:    return DataType<_Tp>::channels;
        -: 2525:}
        -: 2526:
        -: 2527:template<typename _Tp> inline
        -: 2528:_Tp& SparseMat_<_Tp>::ref(int i0, size_t* hashval)
        -: 2529:{
        -: 2530:    return SparseMat::ref<_Tp>(i0, hashval);
        -: 2531:}
        -: 2532:
        -: 2533:template<typename _Tp> inline
        -: 2534:_Tp SparseMat_<_Tp>::operator()(int i0, size_t* hashval) const
        -: 2535:{
        -: 2536:    return SparseMat::value<_Tp>(i0, hashval);
        -: 2537:}
        -: 2538:
        -: 2539:template<typename _Tp> inline
        -: 2540:_Tp& SparseMat_<_Tp>::ref(int i0, int i1, size_t* hashval)
        -: 2541:{
        -: 2542:    return SparseMat::ref<_Tp>(i0, i1, hashval);
        -: 2543:}
        -: 2544:
        -: 2545:template<typename _Tp> inline
        -: 2546:_Tp SparseMat_<_Tp>::operator()(int i0, int i1, size_t* hashval) const
        -: 2547:{
        -: 2548:    return SparseMat::value<_Tp>(i0, i1, hashval);
        -: 2549:}
        -: 2550:
        -: 2551:template<typename _Tp> inline
        -: 2552:_Tp& SparseMat_<_Tp>::ref(int i0, int i1, int i2, size_t* hashval)
        -: 2553:{
        -: 2554:    return SparseMat::ref<_Tp>(i0, i1, i2, hashval);
        -: 2555:}
        -: 2556:
        -: 2557:template<typename _Tp> inline
        -: 2558:_Tp SparseMat_<_Tp>::operator()(int i0, int i1, int i2, size_t* hashval) const
        -: 2559:{
        -: 2560:    return SparseMat::value<_Tp>(i0, i1, i2, hashval);
        -: 2561:}
        -: 2562:
        -: 2563:template<typename _Tp> inline
        -: 2564:_Tp& SparseMat_<_Tp>::ref(const int* idx, size_t* hashval)
        -: 2565:{
        -: 2566:    return SparseMat::ref<_Tp>(idx, hashval);
        -: 2567:}
        -: 2568:
        -: 2569:template<typename _Tp> inline
        -: 2570:_Tp SparseMat_<_Tp>::operator()(const int* idx, size_t* hashval) const
        -: 2571:{
        -: 2572:    return SparseMat::value<_Tp>(idx, hashval);
        -: 2573:}
        -: 2574:
        -: 2575:template<typename _Tp> inline
        -: 2576:SparseMatIterator_<_Tp> SparseMat_<_Tp>::begin()
        -: 2577:{
        -: 2578:    return SparseMatIterator_<_Tp>(this);
        -: 2579:}
        -: 2580:
        -: 2581:template<typename _Tp> inline
        -: 2582:SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::begin() const
        -: 2583:{
        -: 2584:    return SparseMatConstIterator_<_Tp>(this);
        -: 2585:}
        -: 2586:
        -: 2587:template<typename _Tp> inline
        -: 2588:SparseMatIterator_<_Tp> SparseMat_<_Tp>::end()
        -: 2589:{
        -: 2590:    SparseMatIterator_<_Tp> it(this);
        -: 2591:    it.seekEnd();
        -: 2592:    return it;
        -: 2593:}
        -: 2594:
        -: 2595:template<typename _Tp> inline
        -: 2596:SparseMatConstIterator_<_Tp> SparseMat_<_Tp>::end() const
        -: 2597:{
        -: 2598:    SparseMatConstIterator_<_Tp> it(this);
        -: 2599:    it.seekEnd();
        -: 2600:    return it;
        -: 2601:}
        -: 2602:
        -: 2603:
        -: 2604:
        -: 2605:////////////////////////// MatConstIterator /////////////////////////
        -: 2606:
        -: 2607:inline
        -: 2608:MatConstIterator::MatConstIterator()
        -: 2609:    : m(0), elemSize(0), ptr(0), sliceStart(0), sliceEnd(0)
        -: 2610:{}
        -: 2611:
        -: 2612:inline
        -: 2613:MatConstIterator::MatConstIterator(const Mat* _m)
        -: 2614:    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
        -: 2615:{
        -: 2616:    if( m && m->isContinuous() )
        -: 2617:    {
        -: 2618:        sliceStart = m->ptr();
        -: 2619:        sliceEnd = sliceStart + m->total()*elemSize;
        -: 2620:    }
        -: 2621:    seek((const int*)0);
        -: 2622:}
        -: 2623:
        -: 2624:inline
        -: 2625:MatConstIterator::MatConstIterator(const Mat* _m, int _row, int _col)
        -: 2626:    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
        -: 2627:{
        -: 2628:    CV_Assert(m && m->dims <= 2);
        -: 2629:    if( m->isContinuous() )
        -: 2630:    {
        -: 2631:        sliceStart = m->ptr();
        -: 2632:        sliceEnd = sliceStart + m->total()*elemSize;
        -: 2633:    }
        -: 2634:    int idx[] = {_row, _col};
        -: 2635:    seek(idx);
        -: 2636:}
        -: 2637:
        -: 2638:inline
        -: 2639:MatConstIterator::MatConstIterator(const Mat* _m, Point _pt)
        -: 2640:    : m(_m), elemSize(_m->elemSize()), ptr(0), sliceStart(0), sliceEnd(0)
        -: 2641:{
        -: 2642:    CV_Assert(m && m->dims <= 2);
        -: 2643:    if( m->isContinuous() )
        -: 2644:    {
        -: 2645:        sliceStart = m->ptr();
        -: 2646:        sliceEnd = sliceStart + m->total()*elemSize;
        -: 2647:    }
        -: 2648:    int idx[] = {_pt.y, _pt.x};
        -: 2649:    seek(idx);
        -: 2650:}
        -: 2651:
        -: 2652:inline
        -: 2653:MatConstIterator::MatConstIterator(const MatConstIterator& it)
        -: 2654:    : m(it.m), elemSize(it.elemSize), ptr(it.ptr), sliceStart(it.sliceStart), sliceEnd(it.sliceEnd)
        -: 2655:{}
        -: 2656:
        -: 2657:inline
        -: 2658:MatConstIterator& MatConstIterator::operator = (const MatConstIterator& it )
        -: 2659:{
        -: 2660:    m = it.m; elemSize = it.elemSize; ptr = it.ptr;
        -: 2661:    sliceStart = it.sliceStart; sliceEnd = it.sliceEnd;
        -: 2662:    return *this;
        -: 2663:}
        -: 2664:
        -: 2665:inline
        -: 2666:const uchar* MatConstIterator::operator *() const
        -: 2667:{
        -: 2668:    return ptr;
        -: 2669:}
        -: 2670:
        -: 2671:inline MatConstIterator& MatConstIterator::operator += (ptrdiff_t ofs)
        -: 2672:{
        -: 2673:    if( !m || ofs == 0 )
        -: 2674:        return *this;
        -: 2675:    ptrdiff_t ofsb = ofs*elemSize;
        -: 2676:    ptr += ofsb;
        -: 2677:    if( ptr < sliceStart || sliceEnd <= ptr )
        -: 2678:    {
        -: 2679:        ptr -= ofsb;
        -: 2680:        seek(ofs, true);
        -: 2681:    }
        -: 2682:    return *this;
        -: 2683:}
        -: 2684:
        -: 2685:inline
        -: 2686:MatConstIterator& MatConstIterator::operator -= (ptrdiff_t ofs)
        -: 2687:{
        -: 2688:    return (*this += -ofs);
        -: 2689:}
        -: 2690:
        -: 2691:inline
        -: 2692:MatConstIterator& MatConstIterator::operator --()
        -: 2693:{
        -: 2694:    if( m && (ptr -= elemSize) < sliceStart )
        -: 2695:    {
        -: 2696:        ptr += elemSize;
        -: 2697:        seek(-1, true);
        -: 2698:    }
        -: 2699:    return *this;
        -: 2700:}
        -: 2701:
        -: 2702:inline
        -: 2703:MatConstIterator MatConstIterator::operator --(int)
        -: 2704:{
        -: 2705:    MatConstIterator b = *this;
        -: 2706:    *this += -1;
        -: 2707:    return b;
        -: 2708:}
        -: 2709:
        -: 2710:inline
        -: 2711:MatConstIterator& MatConstIterator::operator ++()
        -: 2712:{
        -: 2713:    if( m && (ptr += elemSize) >= sliceEnd )
        -: 2714:    {
        -: 2715:        ptr -= elemSize;
        -: 2716:        seek(1, true);
        -: 2717:    }
        -: 2718:    return *this;
        -: 2719:}
        -: 2720:
        -: 2721:inline MatConstIterator MatConstIterator::operator ++(int)
        -: 2722:{
        -: 2723:    MatConstIterator b = *this;
        -: 2724:    *this += 1;
        -: 2725:    return b;
        -: 2726:}
        -: 2727:
        -: 2728:
        -: 2729:static inline
        -: 2730:bool operator == (const MatConstIterator& a, const MatConstIterator& b)
        -: 2731:{
        -: 2732:    return a.m == b.m && a.ptr == b.ptr;
        -: 2733:}
        -: 2734:
        -: 2735:static inline
        -: 2736:bool operator != (const MatConstIterator& a, const MatConstIterator& b)
        -: 2737:{
        -: 2738:    return !(a == b);
        -: 2739:}
        -: 2740:
        -: 2741:static inline
        -: 2742:bool operator < (const MatConstIterator& a, const MatConstIterator& b)
        -: 2743:{
        -: 2744:    return a.ptr < b.ptr;
        -: 2745:}
        -: 2746:
        -: 2747:static inline
        -: 2748:bool operator > (const MatConstIterator& a, const MatConstIterator& b)
        -: 2749:{
        -: 2750:    return a.ptr > b.ptr;
        -: 2751:}
        -: 2752:
        -: 2753:static inline
        -: 2754:bool operator <= (const MatConstIterator& a, const MatConstIterator& b)
        -: 2755:{
        -: 2756:    return a.ptr <= b.ptr;
        -: 2757:}
        -: 2758:
        -: 2759:static inline
        -: 2760:bool operator >= (const MatConstIterator& a, const MatConstIterator& b)
        -: 2761:{
        -: 2762:    return a.ptr >= b.ptr;
        -: 2763:}
        -: 2764:
        -: 2765:static inline
        -: 2766:ptrdiff_t operator - (const MatConstIterator& b, const MatConstIterator& a)
        -: 2767:{
        -: 2768:    if( a.m != b.m )
        -: 2769:        return ((size_t)(-1) >> 1);
        -: 2770:    if( a.sliceEnd == b.sliceEnd )
        -: 2771:        return (b.ptr - a.ptr)/static_cast<ptrdiff_t>(b.elemSize);
        -: 2772:
        -: 2773:    return b.lpos() - a.lpos();
        -: 2774:}
        -: 2775:
        -: 2776:static inline
        -: 2777:MatConstIterator operator + (const MatConstIterator& a, ptrdiff_t ofs)
        -: 2778:{
        -: 2779:    MatConstIterator b = a;
        -: 2780:    return b += ofs;
        -: 2781:}
        -: 2782:
        -: 2783:static inline
        -: 2784:MatConstIterator operator + (ptrdiff_t ofs, const MatConstIterator& a)
        -: 2785:{
        -: 2786:    MatConstIterator b = a;
        -: 2787:    return b += ofs;
        -: 2788:}
        -: 2789:
        -: 2790:static inline
        -: 2791:MatConstIterator operator - (const MatConstIterator& a, ptrdiff_t ofs)
        -: 2792:{
        -: 2793:    MatConstIterator b = a;
        -: 2794:    return b += -ofs;
        -: 2795:}
        -: 2796:
        -: 2797:
        -: 2798:inline
        -: 2799:const uchar* MatConstIterator::operator [](ptrdiff_t i) const
        -: 2800:{
        -: 2801:    return *(*this + i);
        -: 2802:}
        -: 2803:
        -: 2804:
        -: 2805:
        -: 2806:///////////////////////// MatConstIterator_ /////////////////////////
        -: 2807:
        -: 2808:template<typename _Tp> inline
        -: 2809:MatConstIterator_<_Tp>::MatConstIterator_()
        -: 2810:{}
        -: 2811:
        -: 2812:template<typename _Tp> inline
        -: 2813:MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m)
        -: 2814:    : MatConstIterator(_m)
        -: 2815:{}
        -: 2816:
        -: 2817:template<typename _Tp> inline
        -: 2818:MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m, int _row, int _col)
        -: 2819:    : MatConstIterator(_m, _row, _col)
        -: 2820:{}
        -: 2821:
        -: 2822:template<typename _Tp> inline
        -: 2823:MatConstIterator_<_Tp>::MatConstIterator_(const Mat_<_Tp>* _m, Point _pt)
        -: 2824:    : MatConstIterator(_m, _pt)
        -: 2825:{}
        -: 2826:
        -: 2827:template<typename _Tp> inline
        -: 2828:MatConstIterator_<_Tp>::MatConstIterator_(const MatConstIterator_& it)
        -: 2829:    : MatConstIterator(it)
        -: 2830:{}
        -: 2831:
        -: 2832:template<typename _Tp> inline
        -: 2833:MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator = (const MatConstIterator_& it )
        -: 2834:{
        -: 2835:    MatConstIterator::operator = (it);
        -: 2836:    return *this;
        -: 2837:}
        -: 2838:
        -: 2839:template<typename _Tp> inline
        -: 2840:const _Tp& MatConstIterator_<_Tp>::operator *() const
        -: 2841:{
        -: 2842:    return *(_Tp*)(this->ptr);
        -: 2843:}
        -: 2844:
        -: 2845:template<typename _Tp> inline
        -: 2846:MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator += (ptrdiff_t ofs)
        -: 2847:{
        -: 2848:    MatConstIterator::operator += (ofs);
        -: 2849:    return *this;
        -: 2850:}
        -: 2851:
        -: 2852:template<typename _Tp> inline
        -: 2853:MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator -= (ptrdiff_t ofs)
        -: 2854:{
        -: 2855:    return (*this += -ofs);
        -: 2856:}
        -: 2857:
        -: 2858:template<typename _Tp> inline
        -: 2859:MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator --()
        -: 2860:{
        -: 2861:    MatConstIterator::operator --();
        -: 2862:    return *this;
        -: 2863:}
        -: 2864:
        -: 2865:template<typename _Tp> inline
        -: 2866:MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator --(int)
        -: 2867:{
        -: 2868:    MatConstIterator_ b = *this;
        -: 2869:    MatConstIterator::operator --();
        -: 2870:    return b;
        -: 2871:}
        -: 2872:
        -: 2873:template<typename _Tp> inline
        -: 2874:MatConstIterator_<_Tp>& MatConstIterator_<_Tp>::operator ++()
        -: 2875:{
        -: 2876:    MatConstIterator::operator ++();
        -: 2877:    return *this;
        -: 2878:}
        -: 2879:
        -: 2880:template<typename _Tp> inline
        -: 2881:MatConstIterator_<_Tp> MatConstIterator_<_Tp>::operator ++(int)
        -: 2882:{
        -: 2883:    MatConstIterator_ b = *this;
        -: 2884:    MatConstIterator::operator ++();
        -: 2885:    return b;
        -: 2886:}
        -: 2887:
        -: 2888:
        -: 2889:template<typename _Tp> inline
        -: 2890:Point MatConstIterator_<_Tp>::pos() const
        -: 2891:{
        -: 2892:    if( !m )
        -: 2893:        return Point();
        -: 2894:    CV_DbgAssert( m->dims <= 2 );
        -: 2895:    if( m->isContinuous() )
        -: 2896:    {
        -: 2897:        ptrdiff_t ofs = (const _Tp*)ptr - (const _Tp*)m->data;
        -: 2898:        int y = (int)(ofs / m->cols);
        -: 2899:        int x = (int)(ofs - (ptrdiff_t)y * m->cols);
        -: 2900:        return Point(x, y);
        -: 2901:    }
        -: 2902:    else
        -: 2903:    {
        -: 2904:        ptrdiff_t ofs = (uchar*)ptr - m->data;
        -: 2905:        int y = (int)(ofs / m->step);
        -: 2906:        int x = (int)((ofs - y * m->step)/sizeof(_Tp));
        -: 2907:        return Point(x, y);
        -: 2908:    }
        -: 2909:}
        -: 2910:
        -: 2911:
        -: 2912:template<typename _Tp> static inline
        -: 2913:bool operator == (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
        -: 2914:{
        -: 2915:    return a.m == b.m && a.ptr == b.ptr;
        -: 2916:}
        -: 2917:
        -: 2918:template<typename _Tp> static inline
        -: 2919:bool operator != (const MatConstIterator_<_Tp>& a, const MatConstIterator_<_Tp>& b)
        -: 2920:{
        -: 2921:    return a.m != b.m || a.ptr != b.ptr;
        -: 2922:}
        -: 2923:
        -: 2924:template<typename _Tp> static inline
        -: 2925:MatConstIterator_<_Tp> operator + (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
        -: 2926:{
        -: 2927:    MatConstIterator t = (const MatConstIterator&)a + ofs;
        -: 2928:    return (MatConstIterator_<_Tp>&)t;
        -: 2929:}
        -: 2930:
        -: 2931:template<typename _Tp> static inline
        -: 2932:MatConstIterator_<_Tp> operator + (ptrdiff_t ofs, const MatConstIterator_<_Tp>& a)
        -: 2933:{
        -: 2934:    MatConstIterator t = (const MatConstIterator&)a + ofs;
        -: 2935:    return (MatConstIterator_<_Tp>&)t;
        -: 2936:}
        -: 2937:
        -: 2938:template<typename _Tp> static inline
        -: 2939:MatConstIterator_<_Tp> operator - (const MatConstIterator_<_Tp>& a, ptrdiff_t ofs)
        -: 2940:{
        -: 2941:    MatConstIterator t = (const MatConstIterator&)a - ofs;
        -: 2942:    return (MatConstIterator_<_Tp>&)t;
        -: 2943:}
        -: 2944:
        -: 2945:template<typename _Tp> inline
        -: 2946:const _Tp& MatConstIterator_<_Tp>::operator [](ptrdiff_t i) const
        -: 2947:{
        -: 2948:    return *(_Tp*)MatConstIterator::operator [](i);
        -: 2949:}
        -: 2950:
        -: 2951:
        -: 2952:
        -: 2953://////////////////////////// MatIterator_ ///////////////////////////
        -: 2954:
        -: 2955:template<typename _Tp> inline
        -: 2956:MatIterator_<_Tp>::MatIterator_()
        -: 2957:    : MatConstIterator_<_Tp>()
        -: 2958:{}
        -: 2959:
        -: 2960:template<typename _Tp> inline
        -: 2961:MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m)
        -: 2962:    : MatConstIterator_<_Tp>(_m)
        -: 2963:{}
        -: 2964:
        -: 2965:template<typename _Tp> inline
        -: 2966:MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, int _row, int _col)
        -: 2967:    : MatConstIterator_<_Tp>(_m, _row, _col)
        -: 2968:{}
        -: 2969:
        -: 2970:template<typename _Tp> inline
        -: 2971:MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, Point _pt)
        -: 2972:    : MatConstIterator_<_Tp>(_m, _pt)
        -: 2973:{}
        -: 2974:
        -: 2975:template<typename _Tp> inline
        -: 2976:MatIterator_<_Tp>::MatIterator_(Mat_<_Tp>* _m, const int* _idx)
        -: 2977:    : MatConstIterator_<_Tp>(_m, _idx)
        -: 2978:{}
        -: 2979:
        -: 2980:template<typename _Tp> inline
        -: 2981:MatIterator_<_Tp>::MatIterator_(const MatIterator_& it)
        -: 2982:    : MatConstIterator_<_Tp>(it)
        -: 2983:{}
        -: 2984:
        -: 2985:template<typename _Tp> inline
        -: 2986:MatIterator_<_Tp>& MatIterator_<_Tp>::operator = (const MatIterator_<_Tp>& it )
        -: 2987:{
        -: 2988:    MatConstIterator::operator = (it);
        -: 2989:    return *this;
        -: 2990:}
        -: 2991:
        -: 2992:template<typename _Tp> inline
        -: 2993:_Tp& MatIterator_<_Tp>::operator *() const
        -: 2994:{
        -: 2995:    return *(_Tp*)(this->ptr);
        -: 2996:}
        -: 2997:
        -: 2998:template<typename _Tp> inline
        -: 2999:MatIterator_<_Tp>& MatIterator_<_Tp>::operator += (ptrdiff_t ofs)
        -: 3000:{
        -: 3001:    MatConstIterator::operator += (ofs);
        -: 3002:    return *this;
        -: 3003:}
        -: 3004:
        -: 3005:template<typename _Tp> inline
        -: 3006:MatIterator_<_Tp>& MatIterator_<_Tp>::operator -= (ptrdiff_t ofs)
        -: 3007:{
        -: 3008:    MatConstIterator::operator += (-ofs);
        -: 3009:    return *this;
        -: 3010:}
        -: 3011:
        -: 3012:template<typename _Tp> inline
        -: 3013:MatIterator_<_Tp>& MatIterator_<_Tp>::operator --()
        -: 3014:{
        -: 3015:    MatConstIterator::operator --();
        -: 3016:    return *this;
        -: 3017:}
        -: 3018:
        -: 3019:template<typename _Tp> inline
        -: 3020:MatIterator_<_Tp> MatIterator_<_Tp>::operator --(int)
        -: 3021:{
        -: 3022:    MatIterator_ b = *this;
        -: 3023:    MatConstIterator::operator --();
        -: 3024:    return b;
        -: 3025:}
        -: 3026:
        -: 3027:template<typename _Tp> inline
        -: 3028:MatIterator_<_Tp>& MatIterator_<_Tp>::operator ++()
        -: 3029:{
        -: 3030:    MatConstIterator::operator ++();
        -: 3031:    return *this;
        -: 3032:}
        -: 3033:
        -: 3034:template<typename _Tp> inline
        -: 3035:MatIterator_<_Tp> MatIterator_<_Tp>::operator ++(int)
        -: 3036:{
        -: 3037:    MatIterator_ b = *this;
        -: 3038:    MatConstIterator::operator ++();
        -: 3039:    return b;
        -: 3040:}
        -: 3041:
        -: 3042:template<typename _Tp> inline
        -: 3043:_Tp& MatIterator_<_Tp>::operator [](ptrdiff_t i) const
        -: 3044:{
        -: 3045:    return *(*this + i);
        -: 3046:}
        -: 3047:
        -: 3048:
        -: 3049:template<typename _Tp> static inline
        -: 3050:bool operator == (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
        -: 3051:{
        -: 3052:    return a.m == b.m && a.ptr == b.ptr;
        -: 3053:}
        -: 3054:
        -: 3055:template<typename _Tp> static inline
        -: 3056:bool operator != (const MatIterator_<_Tp>& a, const MatIterator_<_Tp>& b)
        -: 3057:{
        -: 3058:    return a.m != b.m || a.ptr != b.ptr;
        -: 3059:}
        -: 3060:
        -: 3061:template<typename _Tp> static inline
        -: 3062:MatIterator_<_Tp> operator + (const MatIterator_<_Tp>& a, ptrdiff_t ofs)
        -: 3063:{
        -: 3064:    MatConstIterator t = (const MatConstIterator&)a + ofs;
        -: 3065:    return (MatIterator_<_Tp>&)t;
        -: 3066:}
        -: 3067:
        -: 3068:template<typename _Tp> static inline
        -: 3069:MatIterator_<_Tp> operator + (ptrdiff_t ofs, const MatIterator_<_Tp>& a)
        -: 3070:{
        -: 3071:    MatConstIterator t = (const MatConstIterator&)a + ofs;
        -: 3072:    return (MatIterator_<_Tp>&)t;
        -: 3073:}
        -: 3074:
        -: 3075:template<typename _Tp> static inline
        -: 3076:MatIterator_<_Tp> operator - (const MatIterator_<_Tp>& a, ptrdiff_t ofs)
        -: 3077:{
        -: 3078:    MatConstIterator t = (const MatConstIterator&)a - ofs;
        -: 3079:    return (MatIterator_<_Tp>&)t;
        -: 3080:}
        -: 3081:
        -: 3082:
        -: 3083:
        -: 3084://///////////////////// SparseMatConstIterator //////////////////////
        -: 3085:
        -: 3086:inline
        -: 3087:SparseMatConstIterator::SparseMatConstIterator()
        -: 3088:    : m(0), hashidx(0), ptr(0)
        -: 3089:{}
        -: 3090:
        -: 3091:inline
        -: 3092:SparseMatConstIterator::SparseMatConstIterator(const SparseMatConstIterator& it)
        -: 3093:    : m(it.m), hashidx(it.hashidx), ptr(it.ptr)
        -: 3094:{}
        -: 3095:
        -: 3096:inline SparseMatConstIterator& SparseMatConstIterator::operator = (const SparseMatConstIterator& it)
        -: 3097:{
        -: 3098:    if( this != &it )
        -: 3099:    {
        -: 3100:        m = it.m;
        -: 3101:        hashidx = it.hashidx;
        -: 3102:        ptr = it.ptr;
        -: 3103:    }
        -: 3104:    return *this;
        -: 3105:}
        -: 3106:
        -: 3107:template<typename _Tp> inline
        -: 3108:const _Tp& SparseMatConstIterator::value() const
        -: 3109:{
        -: 3110:    return *(const _Tp*)ptr;
        -: 3111:}
        -: 3112:
        -: 3113:inline
        -: 3114:const SparseMat::Node* SparseMatConstIterator::node() const
        -: 3115:{
        -: 3116:    return (ptr && m && m->hdr) ? (const SparseMat::Node*)(const void*)(ptr - m->hdr->valueOffset) : 0;
        -: 3117:}
        -: 3118:
        -: 3119:inline
        -: 3120:SparseMatConstIterator SparseMatConstIterator::operator ++(int)
        -: 3121:{
        -: 3122:    SparseMatConstIterator it = *this;
        -: 3123:    ++*this;
        -: 3124:    return it;
        -: 3125:}
        -: 3126:
        -: 3127:inline
        -: 3128:void SparseMatConstIterator::seekEnd()
        -: 3129:{
        -: 3130:    if( m && m->hdr )
        -: 3131:    {
        -: 3132:        hashidx = m->hdr->hashtab.size();
        -: 3133:        ptr = 0;
        -: 3134:    }
        -: 3135:}
        -: 3136:
        -: 3137:
        -: 3138:static inline
        -: 3139:bool operator == (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
        -: 3140:{
        -: 3141:    return it1.m == it2.m && it1.ptr == it2.ptr;
        -: 3142:}
        -: 3143:
        -: 3144:static inline
        -: 3145:bool operator != (const SparseMatConstIterator& it1, const SparseMatConstIterator& it2)
        -: 3146:{
        -: 3147:    return !(it1 == it2);
        -: 3148:}
        -: 3149:
        -: 3150:
        -: 3151:
        -: 3152:///////////////////////// SparseMatIterator /////////////////////////
        -: 3153:
        -: 3154:inline
        -: 3155:SparseMatIterator::SparseMatIterator()
        -: 3156:{}
        -: 3157:
        -: 3158:inline
        -: 3159:SparseMatIterator::SparseMatIterator(SparseMat* _m)
        -: 3160:    : SparseMatConstIterator(_m)
        -: 3161:{}
        -: 3162:
        -: 3163:inline
        -: 3164:SparseMatIterator::SparseMatIterator(const SparseMatIterator& it)
        -: 3165:    : SparseMatConstIterator(it)
        -: 3166:{}
        -: 3167:
        -: 3168:inline
        -: 3169:SparseMatIterator& SparseMatIterator::operator = (const SparseMatIterator& it)
        -: 3170:{
        -: 3171:    (SparseMatConstIterator&)*this = it;
        -: 3172:    return *this;
        -: 3173:}
        -: 3174:
        -: 3175:template<typename _Tp> inline
        -: 3176:_Tp& SparseMatIterator::value() const
        -: 3177:{
        -: 3178:    return *(_Tp*)ptr;
        -: 3179:}
        -: 3180:
        -: 3181:inline
        -: 3182:SparseMat::Node* SparseMatIterator::node() const
        -: 3183:{
        -: 3184:    return (SparseMat::Node*)SparseMatConstIterator::node();
        -: 3185:}
        -: 3186:
        -: 3187:inline
        -: 3188:SparseMatIterator& SparseMatIterator::operator ++()
        -: 3189:{
        -: 3190:    SparseMatConstIterator::operator ++();
        -: 3191:    return *this;
        -: 3192:}
        -: 3193:
        -: 3194:inline
        -: 3195:SparseMatIterator SparseMatIterator::operator ++(int)
        -: 3196:{
        -: 3197:    SparseMatIterator it = *this;
        -: 3198:    ++*this;
        -: 3199:    return it;
        -: 3200:}
        -: 3201:
        -: 3202:
        -: 3203:
        -: 3204:////////////////////// SparseMatConstIterator_ //////////////////////
        -: 3205:
        -: 3206:template<typename _Tp> inline
        -: 3207:SparseMatConstIterator_<_Tp>::SparseMatConstIterator_()
        -: 3208:{}
        -: 3209:
        -: 3210:template<typename _Tp> inline
        -: 3211:SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMat_<_Tp>* _m)
        -: 3212:    : SparseMatConstIterator(_m)
        -: 3213:{}
        -: 3214:
        -: 3215:template<typename _Tp> inline
        -: 3216:SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMat* _m)
        -: 3217:    : SparseMatConstIterator(_m)
        -: 3218:{
        -: 3219:    CV_Assert( _m->type() == traits::Type<_Tp>::value );
        -: 3220:}
        -: 3221:
        -: 3222:template<typename _Tp> inline
        -: 3223:SparseMatConstIterator_<_Tp>::SparseMatConstIterator_(const SparseMatConstIterator_<_Tp>& it)
        -: 3224:    : SparseMatConstIterator(it)
        -: 3225:{}
        -: 3226:
        -: 3227:template<typename _Tp> inline
        -: 3228:SparseMatConstIterator_<_Tp>& SparseMatConstIterator_<_Tp>::operator = (const SparseMatConstIterator_<_Tp>& it)
        -: 3229:{
        -: 3230:    return reinterpret_cast<SparseMatConstIterator_<_Tp>&>
        -: 3231:         (*reinterpret_cast<SparseMatConstIterator*>(this) =
        -: 3232:           reinterpret_cast<const SparseMatConstIterator&>(it));
        -: 3233:}
        -: 3234:
        -: 3235:template<typename _Tp> inline
        -: 3236:const _Tp& SparseMatConstIterator_<_Tp>::operator *() const
        -: 3237:{
        -: 3238:    return *(const _Tp*)this->ptr;
        -: 3239:}
        -: 3240:
        -: 3241:template<typename _Tp> inline
        -: 3242:SparseMatConstIterator_<_Tp>& SparseMatConstIterator_<_Tp>::operator ++()
        -: 3243:{
        -: 3244:    SparseMatConstIterator::operator ++();
        -: 3245:    return *this;
        -: 3246:}
        -: 3247:
        -: 3248:template<typename _Tp> inline
        -: 3249:SparseMatConstIterator_<_Tp> SparseMatConstIterator_<_Tp>::operator ++(int)
        -: 3250:{
        -: 3251:    SparseMatConstIterator_<_Tp> it = *this;
        -: 3252:    SparseMatConstIterator::operator ++();
        -: 3253:    return it;
        -: 3254:}
        -: 3255:
        -: 3256:
        -: 3257:
        -: 3258:///////////////////////// SparseMatIterator_ ////////////////////////
        -: 3259:
        -: 3260:template<typename _Tp> inline
        -: 3261:SparseMatIterator_<_Tp>::SparseMatIterator_()
        -: 3262:{}
        -: 3263:
        -: 3264:template<typename _Tp> inline
        -: 3265:SparseMatIterator_<_Tp>::SparseMatIterator_(SparseMat_<_Tp>* _m)
        -: 3266:    : SparseMatConstIterator_<_Tp>(_m)
        -: 3267:{}
        -: 3268:
        -: 3269:template<typename _Tp> inline
        -: 3270:SparseMatIterator_<_Tp>::SparseMatIterator_(SparseMat* _m)
        -: 3271:    : SparseMatConstIterator_<_Tp>(_m)
        -: 3272:{}
        -: 3273:
        -: 3274:template<typename _Tp> inline
        -: 3275:SparseMatIterator_<_Tp>::SparseMatIterator_(const SparseMatIterator_<_Tp>& it)
        -: 3276:    : SparseMatConstIterator_<_Tp>(it)
        -: 3277:{}
        -: 3278:
        -: 3279:template<typename _Tp> inline
        -: 3280:SparseMatIterator_<_Tp>& SparseMatIterator_<_Tp>::operator = (const SparseMatIterator_<_Tp>& it)
        -: 3281:{
        -: 3282:    return reinterpret_cast<SparseMatIterator_<_Tp>&>
        -: 3283:         (*reinterpret_cast<SparseMatConstIterator*>(this) =
        -: 3284:           reinterpret_cast<const SparseMatConstIterator&>(it));
        -: 3285:}
        -: 3286:
        -: 3287:template<typename _Tp> inline
        -: 3288:_Tp& SparseMatIterator_<_Tp>::operator *() const
        -: 3289:{
        -: 3290:    return *(_Tp*)this->ptr;
        -: 3291:}
        -: 3292:
        -: 3293:template<typename _Tp> inline
        -: 3294:SparseMatIterator_<_Tp>& SparseMatIterator_<_Tp>::operator ++()
        -: 3295:{
        -: 3296:    SparseMatConstIterator::operator ++();
        -: 3297:    return *this;
        -: 3298:}
        -: 3299:
        -: 3300:template<typename _Tp> inline
        -: 3301:SparseMatIterator_<_Tp> SparseMatIterator_<_Tp>::operator ++(int)
        -: 3302:{
        -: 3303:    SparseMatIterator_<_Tp> it = *this;
        -: 3304:    SparseMatConstIterator::operator ++();
        -: 3305:    return it;
        -: 3306:}
        -: 3307:
        -: 3308:
        -: 3309:
        -: 3310://////////////////////// MatCommaInitializer_ ///////////////////////
        -: 3311:
        -: 3312:template<typename _Tp> inline
        -: 3313:MatCommaInitializer_<_Tp>::MatCommaInitializer_(Mat_<_Tp>* _m)
        -: 3314:    : it(_m)
        -: 3315:{}
        -: 3316:
        -: 3317:template<typename _Tp> template<typename T2> inline
        -: 3318:MatCommaInitializer_<_Tp>& MatCommaInitializer_<_Tp>::operator , (T2 v)
        -: 3319:{
        -: 3320:    CV_DbgAssert( this->it < ((const Mat_<_Tp>*)this->it.m)->end() );
        -: 3321:    *this->it = _Tp(v);
        -: 3322:    ++this->it;
        -: 3323:    return *this;
        -: 3324:}
        -: 3325:
        -: 3326:template<typename _Tp> inline
        -: 3327:MatCommaInitializer_<_Tp>::operator Mat_<_Tp>() const
        -: 3328:{
        -: 3329:    CV_DbgAssert( this->it == ((const Mat_<_Tp>*)this->it.m)->end() );
        -: 3330:    return Mat_<_Tp>(*this->it.m);
        -: 3331:}
        -: 3332:
        -: 3333:
        -: 3334:template<typename _Tp, typename T2> static inline
        -: 3335:MatCommaInitializer_<_Tp> operator << (const Mat_<_Tp>& m, T2 val)
        -: 3336:{
        -: 3337:    MatCommaInitializer_<_Tp> commaInitializer((Mat_<_Tp>*)&m);
        -: 3338:    return (commaInitializer, val);
        -: 3339:}
        -: 3340:
        -: 3341:
        -: 3342:
        -: 3343:///////////////////////// Matrix Expressions ////////////////////////
        -: 3344:
        -: 3345:inline
        -: 3346:Mat& Mat::operator = (const MatExpr& e)
        -: 3347:{
        -: 3348:    e.op->assign(e, *this);
        -: 3349:    return *this;
        -: 3350:}
        -: 3351:
        -: 3352:template<typename _Tp> inline
        -: 3353:Mat_<_Tp>::Mat_(const MatExpr& e)
        -: 3354:{
        -: 3355:    e.op->assign(e, *this, traits::Type<_Tp>::value);
        -: 3356:}
        -: 3357:
        -: 3358:template<typename _Tp> inline
        -: 3359:Mat_<_Tp>& Mat_<_Tp>::operator = (const MatExpr& e)
        -: 3360:{
        -: 3361:    e.op->assign(e, *this, traits::Type<_Tp>::value);
        -: 3362:    return *this;
        -: 3363:}
        -: 3364:
        -: 3365:template<typename _Tp> inline
        -: 3366:MatExpr Mat_<_Tp>::zeros(int rows, int cols)
        -: 3367:{
        -: 3368:    return Mat::zeros(rows, cols, traits::Type<_Tp>::value);
        -: 3369:}
        -: 3370:
        -: 3371:template<typename _Tp> inline
        -: 3372:MatExpr Mat_<_Tp>::zeros(Size sz)
        -: 3373:{
        -: 3374:    return Mat::zeros(sz, traits::Type<_Tp>::value);
        -: 3375:}
        -: 3376:
        -: 3377:template<typename _Tp> inline
        -: 3378:MatExpr Mat_<_Tp>::ones(int rows, int cols)
        -: 3379:{
        -: 3380:    return Mat::ones(rows, cols, traits::Type<_Tp>::value);
        -: 3381:}
        -: 3382:
        -: 3383:template<typename _Tp> inline
        -: 3384:MatExpr Mat_<_Tp>::ones(Size sz)
        -: 3385:{
        -: 3386:    return Mat::ones(sz, traits::Type<_Tp>::value);
        -: 3387:}
        -: 3388:
        -: 3389:template<typename _Tp> inline
        -: 3390:MatExpr Mat_<_Tp>::eye(int rows, int cols)
        -: 3391:{
        -: 3392:    return Mat::eye(rows, cols, traits::Type<_Tp>::value);
        -: 3393:}
        -: 3394:
        -: 3395:template<typename _Tp> inline
        -: 3396:MatExpr Mat_<_Tp>::eye(Size sz)
        -: 3397:{
        -: 3398:    return Mat::eye(sz, traits::Type<_Tp>::value);
        -: 3399:}
        -: 3400:
        -: 3401:inline
        -: 3402:MatExpr::MatExpr()
        -: 3403:    : op(0), flags(0), a(Mat()), b(Mat()), c(Mat()), alpha(0), beta(0), s()
        -: 3404:{}
        -: 3405:
        -: 3406:inline
        -: 3407:MatExpr::MatExpr(const MatOp* _op, int _flags, const Mat& _a, const Mat& _b,
        -: 3408:                 const Mat& _c, double _alpha, double _beta, const Scalar& _s)
        -: 3409:    : op(_op), flags(_flags), a(_a), b(_b), c(_c), alpha(_alpha), beta(_beta), s(_s)
        -: 3410:{}
        -: 3411:
        -: 3412:inline
        -: 3413:MatExpr::operator Mat() const
        -: 3414:{
        -: 3415:    Mat m;
        -: 3416:    op->assign(*this, m);
        -: 3417:    return m;
        -: 3418:}
        -: 3419:
        -: 3420:template<typename _Tp> inline
        -: 3421:MatExpr::operator Mat_<_Tp>() const
        -: 3422:{
        -: 3423:    Mat_<_Tp> m;
        -: 3424:    op->assign(*this, m, traits::Type<_Tp>::value);
        -: 3425:    return m;
        -: 3426:}
        -: 3427:
        -: 3428:
        -: 3429:template<typename _Tp> static inline
        -: 3430:MatExpr min(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
        -: 3431:{
        -: 3432:    return cv::min((const Mat&)a, (const Mat&)b);
        -: 3433:}
        -: 3434:
        -: 3435:template<typename _Tp> static inline
        -: 3436:MatExpr min(const Mat_<_Tp>& a, double s)
        -: 3437:{
        -: 3438:    return cv::min((const Mat&)a, s);
        -: 3439:}
        -: 3440:
        -: 3441:template<typename _Tp> static inline
        -: 3442:MatExpr min(double s, const Mat_<_Tp>& a)
        -: 3443:{
        -: 3444:    return cv::min((const Mat&)a, s);
        -: 3445:}
        -: 3446:
        -: 3447:template<typename _Tp> static inline
        -: 3448:MatExpr max(const Mat_<_Tp>& a, const Mat_<_Tp>& b)
        -: 3449:{
        -: 3450:    return cv::max((const Mat&)a, (const Mat&)b);
        -: 3451:}
        -: 3452:
        -: 3453:template<typename _Tp> static inline
        -: 3454:MatExpr max(const Mat_<_Tp>& a, double s)
        -: 3455:{
        -: 3456:    return cv::max((const Mat&)a, s);
        -: 3457:}
        -: 3458:
        -: 3459:template<typename _Tp> static inline
        -: 3460:MatExpr max(double s, const Mat_<_Tp>& a)
        -: 3461:{
        -: 3462:    return cv::max((const Mat&)a, s);
        -: 3463:}
        -: 3464:
        -: 3465:template<typename _Tp> static inline
        -: 3466:MatExpr abs(const Mat_<_Tp>& m)
        -: 3467:{
        -: 3468:    return cv::abs((const Mat&)m);
        -: 3469:}
        -: 3470:
        -: 3471:
        -: 3472:static inline
        -: 3473:Mat& operator += (Mat& a, const MatExpr& b)
        -: 3474:{
        -: 3475:    b.op->augAssignAdd(b, a);
        -: 3476:    return a;
        -: 3477:}
        -: 3478:
        -: 3479:static inline
        -: 3480:const Mat& operator += (const Mat& a, const MatExpr& b)
        -: 3481:{
        -: 3482:    b.op->augAssignAdd(b, (Mat&)a);
        -: 3483:    return a;
        -: 3484:}
        -: 3485:
        -: 3486:template<typename _Tp> static inline
        -: 3487:Mat_<_Tp>& operator += (Mat_<_Tp>& a, const MatExpr& b)
        -: 3488:{
        -: 3489:    b.op->augAssignAdd(b, a);
        -: 3490:    return a;
        -: 3491:}
        -: 3492:
        -: 3493:template<typename _Tp> static inline
        -: 3494:const Mat_<_Tp>& operator += (const Mat_<_Tp>& a, const MatExpr& b)
        -: 3495:{
        -: 3496:    b.op->augAssignAdd(b, (Mat&)a);
        -: 3497:    return a;
        -: 3498:}
        -: 3499:
        -: 3500:static inline
        -: 3501:Mat& operator -= (Mat& a, const MatExpr& b)
        -: 3502:{
        -: 3503:    b.op->augAssignSubtract(b, a);
        -: 3504:    return a;
        -: 3505:}
        -: 3506:
        -: 3507:static inline
        -: 3508:const Mat& operator -= (const Mat& a, const MatExpr& b)
        -: 3509:{
        -: 3510:    b.op->augAssignSubtract(b, (Mat&)a);
        -: 3511:    return a;
        -: 3512:}
        -: 3513:
        -: 3514:template<typename _Tp> static inline
        -: 3515:Mat_<_Tp>& operator -= (Mat_<_Tp>& a, const MatExpr& b)
        -: 3516:{
        -: 3517:    b.op->augAssignSubtract(b, a);
        -: 3518:    return a;
        -: 3519:}
        -: 3520:
        -: 3521:template<typename _Tp> static inline
        -: 3522:const Mat_<_Tp>& operator -= (const Mat_<_Tp>& a, const MatExpr& b)
        -: 3523:{
        -: 3524:    b.op->augAssignSubtract(b, (Mat&)a);
        -: 3525:    return a;
        -: 3526:}
        -: 3527:
        -: 3528:static inline
        -: 3529:Mat& operator *= (Mat& a, const MatExpr& b)
        -: 3530:{
        -: 3531:    b.op->augAssignMultiply(b, a);
        -: 3532:    return a;
        -: 3533:}
        -: 3534:
        -: 3535:static inline
        -: 3536:const Mat& operator *= (const Mat& a, const MatExpr& b)
        -: 3537:{
        -: 3538:    b.op->augAssignMultiply(b, (Mat&)a);
        -: 3539:    return a;
        -: 3540:}
        -: 3541:
        -: 3542:template<typename _Tp> static inline
        -: 3543:Mat_<_Tp>& operator *= (Mat_<_Tp>& a, const MatExpr& b)
        -: 3544:{
        -: 3545:    b.op->augAssignMultiply(b, a);
        -: 3546:    return a;
        -: 3547:}
        -: 3548:
        -: 3549:template<typename _Tp> static inline
        -: 3550:const Mat_<_Tp>& operator *= (const Mat_<_Tp>& a, const MatExpr& b)
        -: 3551:{
        -: 3552:    b.op->augAssignMultiply(b, (Mat&)a);
        -: 3553:    return a;
        -: 3554:}
        -: 3555:
        -: 3556:static inline
        -: 3557:Mat& operator /= (Mat& a, const MatExpr& b)
        -: 3558:{
        -: 3559:    b.op->augAssignDivide(b, a);
        -: 3560:    return a;
        -: 3561:}
        -: 3562:
        -: 3563:static inline
        -: 3564:const Mat& operator /= (const Mat& a, const MatExpr& b)
        -: 3565:{
        -: 3566:    b.op->augAssignDivide(b, (Mat&)a);
        -: 3567:    return a;
        -: 3568:}
        -: 3569:
        -: 3570:template<typename _Tp> static inline
        -: 3571:Mat_<_Tp>& operator /= (Mat_<_Tp>& a, const MatExpr& b)
        -: 3572:{
        -: 3573:    b.op->augAssignDivide(b, a);
        -: 3574:    return a;
        -: 3575:}
        -: 3576:
        -: 3577:template<typename _Tp> static inline
        -: 3578:const Mat_<_Tp>& operator /= (const Mat_<_Tp>& a, const MatExpr& b)
        -: 3579:{
        -: 3580:    b.op->augAssignDivide(b, (Mat&)a);
        -: 3581:    return a;
        -: 3582:}
        -: 3583:
        -: 3584:
        -: 3585://////////////////////////////// UMat ////////////////////////////////
        -: 3586:
        -: 3587:inline
        -: 3588:UMat::UMat(UMatUsageFlags _usageFlags)
        -: 3589:: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
        -: 3590:{}
        -: 3591:
        -: 3592:inline
        -: 3593:UMat::UMat(int _rows, int _cols, int _type, UMatUsageFlags _usageFlags)
        -: 3594:: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
        -: 3595:{
        -: 3596:    create(_rows, _cols, _type);
        -: 3597:}
        -: 3598:
        -: 3599:inline
        -: 3600:UMat::UMat(int _rows, int _cols, int _type, const Scalar& _s, UMatUsageFlags _usageFlags)
        -: 3601:: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
        -: 3602:{
        -: 3603:    create(_rows, _cols, _type);
        -: 3604:    *this = _s;
        -: 3605:}
        -: 3606:
        -: 3607:inline
        -: 3608:UMat::UMat(Size _sz, int _type, UMatUsageFlags _usageFlags)
        -: 3609:: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
        -: 3610:{
        -: 3611:    create( _sz.height, _sz.width, _type );
        -: 3612:}
        -: 3613:
        -: 3614:inline
        -: 3615:UMat::UMat(Size _sz, int _type, const Scalar& _s, UMatUsageFlags _usageFlags)
        -: 3616:: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
        -: 3617:{
        -: 3618:    create(_sz.height, _sz.width, _type);
        -: 3619:    *this = _s;
        -: 3620:}
        -: 3621:
        -: 3622:inline
        -: 3623:UMat::UMat(int _dims, const int* _sz, int _type, UMatUsageFlags _usageFlags)
        -: 3624:: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
        -: 3625:{
        -: 3626:    create(_dims, _sz, _type);
        -: 3627:}
        -: 3628:
        -: 3629:inline
        -: 3630:UMat::UMat(int _dims, const int* _sz, int _type, const Scalar& _s, UMatUsageFlags _usageFlags)
        -: 3631:: flags(MAGIC_VAL), dims(0), rows(0), cols(0), allocator(0), usageFlags(_usageFlags), u(0), offset(0), size(&rows)
        -: 3632:{
        -: 3633:    create(_dims, _sz, _type);
        -: 3634:    *this = _s;
        -: 3635:}
        -: 3636:
        -: 3637:inline
        -: 3638:UMat::UMat(const UMat& m)
        -: 3639:: flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), allocator(m.allocator),
        -: 3640:  usageFlags(m.usageFlags), u(m.u), offset(m.offset), size(&rows)
        -: 3641:{
        -: 3642:    addref();
        -: 3643:    if( m.dims <= 2 )
        -: 3644:    {
        -: 3645:        step[0] = m.step[0]; step[1] = m.step[1];
        -: 3646:    }
        -: 3647:    else
        -: 3648:    {
        -: 3649:        dims = 0;
        -: 3650:        copySize(m);
        -: 3651:    }
        -: 3652:}
        -: 3653:
        -: 3654:
        -: 3655:template<typename _Tp> inline
        -: 3656:UMat::UMat(const std::vector<_Tp>& vec, bool copyData)
        -: 3657:: flags(MAGIC_VAL + traits::Type<_Tp>::value + CV_MAT_CONT_FLAG), dims(2), rows((int)vec.size()),
        -: 3658:cols(1), allocator(0), usageFlags(USAGE_DEFAULT), u(0), offset(0), size(&rows)
        -: 3659:{
        -: 3660:    if(vec.empty())
        -: 3661:        return;
        -: 3662:    if( !copyData )
        -: 3663:    {
        -: 3664:        // !!!TODO!!!
        -: 3665:        CV_Error(Error::StsNotImplemented, "");
        -: 3666:    }
        -: 3667:    else
        -: 3668:        Mat((int)vec.size(), 1, traits::Type<_Tp>::value, (uchar*)&vec[0]).copyTo(*this);
        -: 3669:}
        -: 3670:
        -: 3671:inline
        -: 3672:UMat& UMat::operator = (const UMat& m)
        -: 3673:{
        -: 3674:    if( this != &m )
        -: 3675:    {
        -: 3676:        const_cast<UMat&>(m).addref();
        -: 3677:        release();
        -: 3678:        flags = m.flags;
        -: 3679:        if( dims <= 2 && m.dims <= 2 )
        -: 3680:        {
        -: 3681:            dims = m.dims;
        -: 3682:            rows = m.rows;
        -: 3683:            cols = m.cols;
        -: 3684:            step[0] = m.step[0];
        -: 3685:            step[1] = m.step[1];
        -: 3686:        }
        -: 3687:        else
        -: 3688:            copySize(m);
        -: 3689:        allocator = m.allocator;
        -: 3690:        if (usageFlags == USAGE_DEFAULT)
        -: 3691:            usageFlags = m.usageFlags;
        -: 3692:        u = m.u;
        -: 3693:        offset = m.offset;
        -: 3694:    }
        -: 3695:    return *this;
        -: 3696:}
        -: 3697:
        -: 3698:inline
        -: 3699:UMat UMat::row(int y) const
        -: 3700:{
        -: 3701:    return UMat(*this, Range(y, y + 1), Range::all());
        -: 3702:}
        -: 3703:
        -: 3704:inline
        -: 3705:UMat UMat::col(int x) const
        -: 3706:{
        -: 3707:    return UMat(*this, Range::all(), Range(x, x + 1));
        -: 3708:}
        -: 3709:
        -: 3710:inline
        -: 3711:UMat UMat::rowRange(int startrow, int endrow) const
        -: 3712:{
        -: 3713:    return UMat(*this, Range(startrow, endrow), Range::all());
        -: 3714:}
        -: 3715:
        -: 3716:inline
        -: 3717:UMat UMat::rowRange(const Range& r) const
        -: 3718:{
        -: 3719:    return UMat(*this, r, Range::all());
        -: 3720:}
        -: 3721:
        -: 3722:inline
        -: 3723:UMat UMat::colRange(int startcol, int endcol) const
        -: 3724:{
        -: 3725:    return UMat(*this, Range::all(), Range(startcol, endcol));
        -: 3726:}
        -: 3727:
        -: 3728:inline
        -: 3729:UMat UMat::colRange(const Range& r) const
        -: 3730:{
        -: 3731:    return UMat(*this, Range::all(), r);
        -: 3732:}
        -: 3733:
        -: 3734:inline
        -: 3735:UMat UMat::clone() const
        -: 3736:{
        -: 3737:    UMat m;
        -: 3738:    copyTo(m);
        -: 3739:    return m;
        -: 3740:}
        -: 3741:
        -: 3742:inline
        -: 3743:void UMat::assignTo( UMat& m, int _type ) const
        -: 3744:{
        -: 3745:    if( _type < 0 )
        -: 3746:        m = *this;
        -: 3747:    else
        -: 3748:        convertTo(m, _type);
        -: 3749:}
        -: 3750:
        -: 3751:inline
        -: 3752:void UMat::create(int _rows, int _cols, int _type, UMatUsageFlags _usageFlags)
        -: 3753:{
        -: 3754:    _type &= TYPE_MASK;
        -: 3755:    if( dims <= 2 && rows == _rows && cols == _cols && type() == _type && u )
        -: 3756:        return;
        -: 3757:    int sz[] = {_rows, _cols};
        -: 3758:    create(2, sz, _type, _usageFlags);
        -: 3759:}
        -: 3760:
        -: 3761:inline
        -: 3762:void UMat::create(Size _sz, int _type, UMatUsageFlags _usageFlags)
        -: 3763:{
        -: 3764:    create(_sz.height, _sz.width, _type, _usageFlags);
        -: 3765:}
        -: 3766:
        -: 3767:inline
        -: 3768:void UMat::addref()
        -: 3769:{
        -: 3770:    if( u )
        -: 3771:        CV_XADD(&(u->urefcount), 1);
        -: 3772:}
        -: 3773:
        -: 3774:inline void UMat::release()
        -: 3775:{
        -: 3776:    if( u && CV_XADD(&(u->urefcount), -1) == 1 )
        -: 3777:        deallocate();
        -: 3778:    for(int i = 0; i < dims; i++)
        -: 3779:        size.p[i] = 0;
        -: 3780:    u = 0;
        -: 3781:}
        -: 3782:
        -: 3783:inline
        -: 3784:UMat UMat::operator()( Range _rowRange, Range _colRange ) const
        -: 3785:{
        -: 3786:    return UMat(*this, _rowRange, _colRange);
        -: 3787:}
        -: 3788:
        -: 3789:inline
        -: 3790:UMat UMat::operator()( const Rect& roi ) const
        -: 3791:{
        -: 3792:    return UMat(*this, roi);
        -: 3793:}
        -: 3794:
        -: 3795:inline
        -: 3796:UMat UMat::operator()(const Range* ranges) const
        -: 3797:{
        -: 3798:    return UMat(*this, ranges);
        -: 3799:}
        -: 3800:
        -: 3801:inline
        -: 3802:UMat UMat::operator()(const std::vector<Range>& ranges) const
        -: 3803:{
        -: 3804:    return UMat(*this, ranges);
        -: 3805:}
        -: 3806:
        -: 3807:inline
        -: 3808:bool UMat::isContinuous() const
        -: 3809:{
        -: 3810:    return (flags & CONTINUOUS_FLAG) != 0;
        -: 3811:}
        -: 3812:
        -: 3813:inline
        -: 3814:bool UMat::isSubmatrix() const
        -: 3815:{
        -: 3816:    return (flags & SUBMATRIX_FLAG) != 0;
        -: 3817:}
        -: 3818:
        -: 3819:inline
        -: 3820:size_t UMat::elemSize() const
        -: 3821:{
        -: 3822:    size_t res = dims > 0 ? step.p[dims - 1] : 0;
        -: 3823:    CV_DbgAssert(res != 0);
        -: 3824:    return res;
        -: 3825:}
        -: 3826:
        -: 3827:inline
        -: 3828:size_t UMat::elemSize1() const
        -: 3829:{
        -: 3830:    return CV_ELEM_SIZE1(flags);
        -: 3831:}
        -: 3832:
        -: 3833:inline
        -: 3834:int UMat::type() const
        -: 3835:{
        -: 3836:    return CV_MAT_TYPE(flags);
        -: 3837:}
        -: 3838:
        -: 3839:inline
        -: 3840:int UMat::depth() const
        -: 3841:{
        -: 3842:    return CV_MAT_DEPTH(flags);
        -: 3843:}
        -: 3844:
        -: 3845:inline
        -: 3846:int UMat::channels() const
        -: 3847:{
        -: 3848:    return CV_MAT_CN(flags);
        -: 3849:}
        -: 3850:
        -: 3851:inline
        -: 3852:size_t UMat::step1(int i) const
        -: 3853:{
        -: 3854:    return step.p[i] / elemSize1();
        -: 3855:}
        -: 3856:
        -: 3857:inline
        -: 3858:bool UMat::empty() const
        -: 3859:{
        -: 3860:    return u == 0 || total() == 0 || dims == 0;
        -: 3861:}
        -: 3862:
        -: 3863:inline
        -: 3864:size_t UMat::total() const
        -: 3865:{
        -: 3866:    if( dims <= 2 )
        -: 3867:        return (size_t)rows * cols;
        -: 3868:    size_t p = 1;
        -: 3869:    for( int i = 0; i < dims; i++ )
        -: 3870:        p *= size[i];
        -: 3871:    return p;
        -: 3872:}
        -: 3873:
        -: 3874:inline
        -: 3875:UMat::UMat(UMat&& m)
        -: 3876:: flags(m.flags), dims(m.dims), rows(m.rows), cols(m.cols), allocator(m.allocator),
        -: 3877:  usageFlags(m.usageFlags), u(m.u), offset(m.offset), size(&rows)
        -: 3878:{
        -: 3879:    if (m.dims <= 2)  // move new step/size info
        -: 3880:    {
        -: 3881:        step[0] = m.step[0];
        -: 3882:        step[1] = m.step[1];
        -: 3883:    }
        -: 3884:    else
        -: 3885:    {
        -: 3886:        CV_DbgAssert(m.step.p != m.step.buf);
        -: 3887:        step.p = m.step.p;
        -: 3888:        size.p = m.size.p;
        -: 3889:        m.step.p = m.step.buf;
        -: 3890:        m.size.p = &m.rows;
        -: 3891:    }
        -: 3892:    m.flags = MAGIC_VAL; m.dims = m.rows = m.cols = 0;
        -: 3893:    m.allocator = NULL;
        -: 3894:    m.u = NULL;
        -: 3895:    m.offset = 0;
        -: 3896:}
        -: 3897:
        -: 3898:inline
        -: 3899:UMat& UMat::operator = (UMat&& m)
        -: 3900:{
        -: 3901:    if (this == &m)
        -: 3902:      return *this;
        -: 3903:    release();
        -: 3904:    flags = m.flags; dims = m.dims; rows = m.rows; cols = m.cols;
        -: 3905:    allocator = m.allocator; usageFlags = m.usageFlags;
        -: 3906:    u = m.u;
        -: 3907:    offset = m.offset;
        -: 3908:    if (step.p != step.buf) // release self step/size
        -: 3909:    {
        -: 3910:        fastFree(step.p);
        -: 3911:        step.p = step.buf;
        -: 3912:        size.p = &rows;
        -: 3913:    }
        -: 3914:    if (m.dims <= 2) // move new step/size info
        -: 3915:    {
        -: 3916:        step[0] = m.step[0];
        -: 3917:        step[1] = m.step[1];
        -: 3918:    }
        -: 3919:    else
        -: 3920:    {
        -: 3921:        CV_DbgAssert(m.step.p != m.step.buf);
        -: 3922:        step.p = m.step.p;
        -: 3923:        size.p = m.size.p;
        -: 3924:        m.step.p = m.step.buf;
        -: 3925:        m.size.p = &m.rows;
        -: 3926:    }
        -: 3927:    m.flags = MAGIC_VAL; m.dims = m.rows = m.cols = 0;
        -: 3928:    m.allocator = NULL;
        -: 3929:    m.u = NULL;
        -: 3930:    m.offset = 0;
        -: 3931:    return *this;
        -: 3932:}
        -: 3933:
        -: 3934:
        -: 3935:inline bool UMatData::hostCopyObsolete() const { return (flags & HOST_COPY_OBSOLETE) != 0; }
        -: 3936:inline bool UMatData::deviceCopyObsolete() const { return (flags & DEVICE_COPY_OBSOLETE) != 0; }
        -: 3937:inline bool UMatData::deviceMemMapped() const { return (flags & DEVICE_MEM_MAPPED) != 0; }
        -: 3938:inline bool UMatData::copyOnMap() const { return (flags & COPY_ON_MAP) != 0; }
        -: 3939:inline bool UMatData::tempUMat() const { return (flags & TEMP_UMAT) != 0; }
        -: 3940:inline bool UMatData::tempCopiedUMat() const { return (flags & TEMP_COPIED_UMAT) == TEMP_COPIED_UMAT; }
        -: 3941:
        -: 3942:inline void UMatData::markDeviceMemMapped(bool flag)
        -: 3943:{
        -: 3944:  if(flag)
        -: 3945:    flags |= DEVICE_MEM_MAPPED;
        -: 3946:  else
        -: 3947:    flags &= ~DEVICE_MEM_MAPPED;
        -: 3948:}
        -: 3949:
        -: 3950:inline void UMatData::markHostCopyObsolete(bool flag)
        -: 3951:{
        -: 3952:    if(flag)
        -: 3953:        flags |= HOST_COPY_OBSOLETE;
        -: 3954:    else
        -: 3955:        flags &= ~HOST_COPY_OBSOLETE;
        -: 3956:}
        -: 3957:inline void UMatData::markDeviceCopyObsolete(bool flag)
        -: 3958:{
        -: 3959:    if(flag)
        -: 3960:        flags |= DEVICE_COPY_OBSOLETE;
        -: 3961:    else
        -: 3962:        flags &= ~DEVICE_COPY_OBSOLETE;
        -: 3963:}
        -: 3964:
        -: 3965://! @endcond
        -: 3966:
        -: 3967:} //cv
        -: 3968:
        -: 3969:#ifdef _MSC_VER
        -: 3970:#pragma warning( pop )
        -: 3971:#endif
        -: 3972:
        -: 3973:#endif
